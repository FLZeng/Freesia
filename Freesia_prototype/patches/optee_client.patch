diff --git a/libteec/CMakeLists.txt b/libteec/CMakeLists.txt
index c742d31..5e29457 100644
--- a/libteec/CMakeLists.txt
+++ b/libteec/CMakeLists.txt
@@ -21,6 +21,8 @@ set(CFG_TEE_CLIENT_LOG_FILE "/data/tee/teec.log" CACHE STRING "Location of libte
 ################################################################################
 set(SRC
 	src/tee_client_api.c
+	src/teec_mutex_pool.c
+	src/teec_mutex_pool_v2.c
 	src/teec_trace.c
 )

@@ -37,6 +39,10 @@ set_target_properties(teec PROPERTIES
 	SOVERSION ${PROJECT_VERSION_MAJOR}
 )

+target_compile_options(teec
+	PRIVATE -march=armv8.5-a+memtag
+)
+
 ################################################################################
 # Flags always set
 ################################################################################
diff --git a/libteec/Makefile b/libteec/Makefile
index 6e80a50..a479b3f 100644
--- a/libteec/Makefile
+++ b/libteec/Makefile
@@ -18,6 +18,8 @@ LIB_MAJ_MIN	:= $(LIB_NAME).$(MAJOR_VERSION).$(MINOR_VERSION)
 LIB_MAJ_MIN_P	:= $(LIB_NAME).$(MAJOR_VERSION).$(MINOR_VERSION).$(PATCH_VERSION)

 TEEC_SRCS	:= tee_client_api.c \
+		   teec_mutex_pool.c \
+		   teec_mutex_pool_v2.c \
 		   teec_trace.c

 TEEC_SRC_DIR	:= src
diff --git a/libteec/include/tee_client_api.h b/libteec/include/tee_client_api.h
index ba0cdc3..ebfe7db 100644
--- a/libteec/include/tee_client_api.h
+++ b/libteec/include/tee_client_api.h
@@ -280,6 +280,7 @@ typedef struct {
 		int fd;
 		bool reg_mem;
 		bool memref_null;
+		bool is_initialized;		// MOD: flag for reentrancy
 	} imp;
 } TEEC_Context;

@@ -324,6 +325,7 @@ typedef struct {
 		void *shadow_buffer;
 		int registered_fd;
 		uint32_t flags;
+		bool is_initialized;		// MOD: flag for reentrancy
 	} imp;
 } TEEC_SharedMemory;

@@ -409,6 +411,7 @@ typedef struct {
 	struct {
 		TEEC_Context *ctx;
 		uint32_t session_id;
+		bool is_initialized;		// MOD: flag for reentrancy
 	} imp;
 } TEEC_Session;

@@ -435,6 +438,7 @@ typedef struct {
 	/* Implementation defined */
 	struct {
 		TEEC_Session *session;
+		bool is_initialized;		// MOD: flag for reentrancy
 	} imp;
 } TEEC_Operation;

diff --git a/libteec/include/teec_mutex_pool.h b/libteec/include/teec_mutex_pool.h
new file mode 100644
index 0000000..c8c1ef8
--- /dev/null
+++ b/libteec/include/teec_mutex_pool.h
@@ -0,0 +1,141 @@
+#ifndef TEEC_MUTEX_POOL_H
+#define TEEC_MUTEX_POOL_H
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <string.h>
+#include <unistd.h>
+
+/**
+ * Defines the maximum size of the mutex pool.
+ */
+#define TEEC_MUTEX_POOL_MAX_SIZE  128
+
+/**
+ * Invalid key
+ */
+#define POOL_INVALID_KEY          0
+
+/**
+ * Transform a pointer to a key.
+ */
+#define ADDR_TO_KEY(ptr)  (uintptr_t)(ptr)
+
+
+// #define TEEC_MUTEX_POOL_INITIALIZER {{ .key = {0}, .val = {0} }}
+
+/**
+ * struct TEEC_Mutex_Pool
+ *
+ * @param capacity  Capacity of the pool.
+ * @param size      Number of entries in the pool.
+ * @param key       List of addr keys.
+ * @param val       List of mutex values.
+ *
+ * A TEEC_Mutex_Pool object contains a list of addr/mutex associations.
+ * Each association is identified by a unique unsigned long key.
+ */
+typedef struct {
+    // size_t capacity;
+    // size_t size;
+    uint64_t key[TEEC_MUTEX_POOL_MAX_SIZE];
+    pthread_mutex_t val[TEEC_MUTEX_POOL_MAX_SIZE];
+} TEEC_Mutex_Pool;
+
+/**
+ * TEEC_Mutex_Mutex_Pool - Create a new TEEC_Mutex_Pool object.
+ *
+ * @param    capacity    Optional initial capacity of the map.
+ * @return   A newly allocated TEEC_Mutex_Pool object.
+ *
+ * This function allocates a new TEEC_Mutex_Pool object of given capacity and
+ * returns it. If you do not know in advance (roughly) the number of entries
+ * in the map, give capacity=0.
+ */
+TEEC_Mutex_Pool TEEC_Mutex_Pool_Create(int capacity);
+
+/**
+ * TEEC_Pool_Destroy - Destroy a TEEC_Mutex_Pool object.
+ *
+ * @param    pool   TEEC_Mutex_Pool object to deallocate.
+ *
+ * Deallocate given pool object and all memory associated to it.
+ */
+/*--------------------------------------------------------------------------*/
+void TEEC_Mutex_Pool_Destroy(TEEC_Mutex_Pool *pool);
+
+/*-------------------------------------------------------------------------*/
+/**
+ * TEEC_Mutex_Pool_Get - Get a mutex from a pool.
+ *
+ * @param    pool    TEEC_Mutex_Pool object to search.
+ * @param    key     Key to look for in the pool.
+ * @return   a pointer to internally allocated mutex.
+ *
+ * This function locates a key in a pool and returns a pointer to its
+ * value (mutex), or null pointer if no such key can be found in pool
+ * and the pool is used up.
+ */
+/*--------------------------------------------------------------------------*/
+pthread_mutex_t *TEEC_Mutex_Pool_Get(TEEC_Mutex_Pool *pool, uint64_t key);
+
+/*-------------------------------------------------------------------------*/
+/**
+ * TEEC_Mutex_Pool_Unset - Remove a key in a pool.
+ *
+ * @param    pool    TEEC_Mutex_Pool object to search.
+ * @param    key     Key to remove.
+ *
+ * This function removes a key in a pool. Nothing is done if the
+ * key cannot be found.
+ */
+/*--------------------------------------------------------------------------*/
+void TEEC_Mutex_Pool_Unset(TEEC_Mutex_Pool *pool, uint64_t key);
+
+size_t TEEC_Mutex_Pool_Size(TEEC_Mutex_Pool *pool);
+
+/*-------------------------------------------------------------------------*/
+/**
+  @brief    Set a value in a map.
+  @param    d       map object to modify.
+  @param    key     Key to modify or add.
+  @param    val     Value to add.
+  @return   int     0 if Ok, anything else otherwise
+
+  If the given key is found in the map, the associated value is
+  replaced by the provided one. If the key cannot be found in the
+  map, it is added to it.
+
+  It is Ok to provide a NULL value for val, but NULL values for the map
+  or the key are considered as errors: the function will return immediately
+  in such a case.
+
+  Notice that if you map_set a variable to NULL, a call to
+  map_get will return a NULL value: the variable will be found, and
+  its value (NULL) is returned. In other words, setting the variable
+  content to NULL is equivalent to deleting the variable from the
+  map. It is not possible (in this implementation) to have a key in
+  the map without value.
+
+  This function returns non-zero in case of failure.
+ */
+/*--------------------------------------------------------------------------*/
+int map_set(TEEC_Mutex_Pool *vd, const char *key, void *val);
+
+/*-------------------------------------------------------------------------*/
+/**
+  @brief    Delete a key in a map
+  @param    d       map object to modify.
+  @param    key     Key to remove.
+  @return   void
+
+  This function deletes a key in a map. Nothing is done if the
+  key cannot be found.
+ */
+/*--------------------------------------------------------------------------*/
+void map_unset(TEEC_Mutex_Pool *d, const char *key);
+
+#endif
diff --git a/libteec/include/teec_mutex_pool_v2.h b/libteec/include/teec_mutex_pool_v2.h
new file mode 100644
index 0000000..2848bb0
--- /dev/null
+++ b/libteec/include/teec_mutex_pool_v2.h
@@ -0,0 +1,143 @@
+#ifndef TEEC_MUTEX_POOL_V2_H
+#define TEEC_MUTEX_POOL_V2_H
+
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <stddef.h>
+#include <string.h>
+#include <unistd.h>
+
+/**
+ * Defines the maximum size of the mutex pool.
+ */
+#define TEEC_MUTEX_POOL_MAX_SIZE  128
+
+#define TEEC_MUTEX_POOL_STEP_SIZE 8
+
+/**
+ * Invalid key
+ */
+#define POOL_INVALID_KEY          0
+
+/**
+ * Transform a pointer to a key.
+ */
+#define ADDR_TO_KEY(ptr)  (uintptr_t)(ptr)
+
+
+// #define TEEC_MUTEX_POOL_INITIALIZER {{ .key = {0}, .val = {0} }}
+
+/**
+ * struct TEEC_Mutex_Pool
+ *
+ * @param capacity  Capacity of the pool.
+ * @param size      Number of entries in the pool.
+ * @param key       List of addr keys.
+ * @param val       List of mutex values.
+ *
+ * A TEEC_Mutex_Pool object contains a list of addr/mutex associations.
+ * Each association is identified by a unique unsigned long key.
+ */
+typedef struct {
+    size_t capacity;
+    size_t size;
+    uint64_t *key;
+    pthread_mutex_t *val;
+} TEEC_Mutex_Pool_V2;
+
+/**
+ * TEEC_Mutex_Pool_V2_Create - Create a new TEEC_Mutex_Pool object.
+ *
+ * @param    capacity    Optional initial capacity of the map.
+ * @return   A newly allocated TEEC_Mutex_Pool object.
+ *
+ * This function allocates a new TEEC_Mutex_Pool object of given capacity and
+ * returns it. If you do not know in advance (roughly) the number of entries
+ * in the map, give capacity=0.
+ */
+TEEC_Mutex_Pool_V2 TEEC_Mutex_Pool_V2_Create(int capacity);
+
+/**
+ * TEEC_Pool_V2_Destroy - Destroy a TEEC_Mutex_Pool object.
+ *
+ * @param    pool   TEEC_Mutex_Pool object to deallocate.
+ *
+ * Deallocate given pool object and all memory associated to it.
+ */
+/*--------------------------------------------------------------------------*/
+void TEEC_Mutex_Pool_V2_Destroy(TEEC_Mutex_Pool_V2 *pool);
+
+/*-------------------------------------------------------------------------*/
+/**
+ * TEEC_Mutex_Pool_V2_Get - Get a mutex from a pool.
+ *
+ * @param    pool    TEEC_Mutex_Pool object to search.
+ * @param    key     Key to look for in the pool.
+ * @return   a pointer to internally allocated mutex.
+ *
+ * This function locates a key in a pool and returns a pointer to its
+ * value (mutex), or null pointer if no such key can be found in pool
+ * and the pool is used up.
+ */
+/*--------------------------------------------------------------------------*/
+pthread_mutex_t *TEEC_Mutex_Pool_V2_Get(TEEC_Mutex_Pool_V2 *pool, uint64_t key);
+
+/*-------------------------------------------------------------------------*/
+/**
+ * TEEC_Mutex_Pool_Unset - Remove a key in a pool.
+ *
+ * @param    pool    TEEC_Mutex_Pool object to search.
+ * @param    key     Key to remove.
+ *
+ * This function removes a key in a pool. Nothing is done if the
+ * key cannot be found.
+ */
+/*--------------------------------------------------------------------------*/
+void TEEC_Mutex_Pool_V2_Unset(TEEC_Mutex_Pool_V2 *pool, uint64_t key);
+
+size_t TEEC_Mutex_Pool_V2_Size(TEEC_Mutex_Pool_V2 *pool);
+
+/*-------------------------------------------------------------------------*/
+/**
+  @brief    Set a value in a map.
+  @param    d       map object to modify.
+  @param    key     Key to modify or add.
+  @param    val     Value to add.
+  @return   int     0 if Ok, anything else otherwise
+
+  If the given key is found in the map, the associated value is
+  replaced by the provided one. If the key cannot be found in the
+  map, it is added to it.
+
+  It is Ok to provide a NULL value for val, but NULL values for the map
+  or the key are considered as errors: the function will return immediately
+  in such a case.
+
+  Notice that if you map_set a variable to NULL, a call to
+  map_get will return a NULL value: the variable will be found, and
+  its value (NULL) is returned. In other words, setting the variable
+  content to NULL is equivalent to deleting the variable from the
+  map. It is not possible (in this implementation) to have a key in
+  the map without value.
+
+  This function returns non-zero in case of failure.
+ */
+/*--------------------------------------------------------------------------*/
+int map_set(TEEC_Mutex_Pool_V2 *vd, const char *key, void *val);
+
+/*-------------------------------------------------------------------------*/
+/**
+  @brief    Delete a key in a map
+  @param    d       map object to modify.
+  @param    key     Key to remove.
+  @return   void
+
+  This function deletes a key in a map. Nothing is done if the
+  key cannot be found.
+ */
+/*--------------------------------------------------------------------------*/
+void map_unset(TEEC_Mutex_Pool_V2 *d, const char *key);
+
+#endif
diff --git a/libteec/src/tee_client_api.c b/libteec/src/tee_client_api.c
index 512fdac..66920bb 100644
--- a/libteec/src/tee_client_api.c
+++ b/libteec/src/tee_client_api.c
@@ -38,6 +38,7 @@
 #include <sys/types.h>
 #include <tee_client_api_extensions.h>
 #include <tee_client_api.h>
+#include <teec_mutex_pool.h>
 #include <teec_trace.h>
 #include <unistd.h>

@@ -63,6 +64,10 @@
 #define SHM_FLAG_SHADOW_BUFFER_ALLOCED	(1u << 1)

 static pthread_mutex_t teec_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex for shared memory
+static pthread_mutex_t teec_shm_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex pool
+static TEEC_Mutex_Pool teec_mutex_pool = { .key = {0}, .val = {PTHREAD_MUTEX_INITIALIZER} };

 static void teec_mutex_lock(pthread_mutex_t *mu)
 {
@@ -166,15 +171,31 @@ TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)
 	if (!ctx)
 		return TEEC_ERROR_BAD_PARAMETERS;

+	// MOD: avoid initializing an ctx more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the ctx object to be initialized with 0
+	*/
+	// teec_mutex_lock(&teec_mutex);
+	// if (ctx->imp.is_initialized) {
+	// 	teec_mutex_unlock(&teec_mutex);
+	// 	return TEEC_ERROR_BAD_PARAMETERS;
+	// }
+	// teec_mutex_unlock(&teec_mutex);
+
 	for (n = 0; n < TEEC_MAX_DEV_SEQ; n++) {
 		uint32_t gen_caps = 0;

 		snprintf(devname, sizeof(devname), "/dev/tee%zu", n);
 		fd = teec_open_dev(devname, name, &gen_caps);
 		if (fd >= 0) {
+			// MOD: add mutex for multi-thread CA call on the same ctx
+			teec_mutex_lock(&teec_mutex);
 			ctx->imp.fd = fd;
 			ctx->imp.reg_mem = gen_caps & TEE_GEN_CAP_REG_MEM;
 			ctx->imp.memref_null = gen_caps & TEE_GEN_CAP_MEMREF_NULL;
+			ctx->imp.is_initialized = true;
+			// MOD: release mutex
+			teec_mutex_unlock(&teec_mutex);
 			return TEEC_SUCCESS;
 		}
 	}
@@ -184,8 +205,17 @@ TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)

 void TEEC_FinalizeContext(TEEC_Context *ctx)
 {
-	if (ctx)
-		close(ctx->imp.fd);
+	if (ctx) {
+		// MOD: add mutex for multi-thread CA call on the same ctx
+		teec_mutex_lock(&teec_mutex);
+		// MOD: avoid finalizing an uninitialized ctx
+		if (ctx->imp.is_initialized) {
+			close(ctx->imp.fd);
+			ctx->imp.is_initialized = false;
+		}
+		// MOD: release mutex
+		teec_mutex_unlock(&teec_mutex);
+	}
 }


@@ -332,8 +362,10 @@ static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
 			struct tee_ioctl_param *params,
 			TEEC_SharedMemory *shms)
 {
-	TEEC_Result res = TEEC_ERROR_GENERIC;
+	TEEC_Result res = TEEC_SUCCESS;
 	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;

 	memset(shms, 0, sizeof(TEEC_SharedMemory) *
 			TEEC_CONFIG_PAYLOAD_REF_COUNT);
@@ -347,6 +379,22 @@ static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
 		return TEEC_SUCCESS;
 	}

+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing an operation more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the operation object to be initialized with 0
+	*/
+	// if (operation->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
 	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
 		uint32_t param_type = 0;

@@ -369,14 +417,14 @@ static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
 				&operation->params[n].tmpref, params + n,
 				shms + n);
 			if (res != TEEC_SUCCESS)
-				return res;
+				goto out;
 			break;
 		case TEEC_MEMREF_WHOLE:
 			res = teec_pre_process_whole(
 					&operation->params[n].memref,
 					params + n);
 			if (res != TEEC_SUCCESS)
-				return res;
+				goto out;
 			break;
 		case TEEC_MEMREF_PARTIAL_INPUT:
 		case TEEC_MEMREF_PARTIAL_OUTPUT:
@@ -384,14 +432,20 @@ static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
 			res = teec_pre_process_partial(param_type,
 				&operation->params[n].memref, params + n);
 			if (res != TEEC_SUCCESS)
-				return res;
+				goto out;
 			break;
 		default:
-			return TEEC_ERROR_BAD_PARAMETERS;
+			res = TEEC_ERROR_BAD_PARAMETERS;
+			goto out;
 		}
 	}
+	operation->imp.is_initialized = true;

-	return TEEC_SUCCESS;
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	return res;
 }

 static void teec_post_process_tmpref(uint32_t param_type,
@@ -454,10 +508,24 @@ static void teec_post_process_operation(TEEC_Operation *operation,
 			TEEC_SharedMemory *shms)
 {
 	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;

 	if (!operation)
 		return;

+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (!operation->imp.is_initialized) {
+		goto out;
+	}
+
 	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
 		uint32_t param_type = 0;

@@ -490,16 +558,30 @@ static void teec_post_process_operation(TEEC_Operation *operation,
 			break;
 		}
 	}
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 }

 static void teec_free_temp_refs(TEEC_Operation *operation,
 			TEEC_SharedMemory *shms)
 {
 	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;

 	if (!operation)
 		return;

+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
 	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
 		switch (TEEC_PARAM_TYPE_GET(operation->paramTypes, n)) {
 		case TEEC_MEMREF_TEMP_INPUT:
@@ -511,6 +593,9 @@ static void teec_free_temp_refs(TEEC_Operation *operation,
 			break;
 		}
 	}
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 }

 static TEEC_Result ioctl_errno_to_res(int err)
@@ -596,6 +681,8 @@ TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,
 			uint32_t connection_method, const void *connection_data,
 			TEEC_Operation *operation, uint32_t *ret_origin)
 {
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
 	struct tee_ioctl_open_session_arg *arg = NULL;
 	struct tee_ioctl_param *params = NULL;
 	TEEC_Result res = TEEC_ERROR_GENERIC;
@@ -621,6 +708,30 @@ TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,
 		goto out;
 	}

+	// MOD: add mutex for multi-thread CA call on the same session
+	key = ADDR_TO_KEY(session);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		// eorig = TEEC_ORIGIN_API;
+		// res = TEEC_ERROR_BUSY;
+		// goto out;
+		mutex = &teec_mutex;
+	}
+
+	// MOD: avoid initializing a session more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the session object to be initialized with 0
+	*/
+	// teec_mutex_lock(mutex);
+	// if (session->imp.is_initialized) {
+	// 	teec_mutex_unlock(mutex);
+	// 	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	// 	eorig = TEEC_ORIGIN_API;
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+	// teec_mutex_unlock(mutex);
+
 	buf_data.buf_ptr = (uintptr_t)&buf;
 	buf_data.buf_len = sizeof(buf);

@@ -648,13 +759,19 @@ TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,
 	res = arg->ret;
 	eorig = arg->ret_origin;
 	if (res == TEEC_SUCCESS) {
+		// MOD: add mutex for multi-thread CA call on the same session
+		teec_mutex_lock(mutex);
 		session->imp.ctx = ctx;
 		session->imp.session_id = arg->session;
+		session->imp.is_initialized = true;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
 	}
 	teec_post_process_operation(operation, params, shm);

 out_free_temp_refs:
 	teec_free_temp_refs(operation, shm);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 out:
 	if (ret_origin)
 		*ret_origin = eorig;
@@ -663,15 +780,38 @@ out:

 void TEEC_CloseSession(TEEC_Session *session)
 {
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
 	struct tee_ioctl_close_session_arg arg;
+	int rc = 0;

 	memset(&arg, 0, sizeof(arg));

 	if (!session)
 		return;

-	arg.session = session->imp.session_id;
-	if (ioctl(session->imp.ctx->imp.fd, TEE_IOC_CLOSE_SESSION, &arg))
+	// MOD: add mutex for multi-thread CA call on the same session
+	key = ADDR_TO_KEY(session);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid close an uninitialized session
+	if (session->imp.is_initialized) {
+		arg.session = session->imp.session_id;
+		rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_CLOSE_SESSION, &arg);
+		if (!rc) {
+			session->imp.is_initialized = false;
+		}
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+
+	if (rc)
 		EMSG("Failed to close session 0x%x", session->imp.session_id);
 }

@@ -747,6 +887,8 @@ out:

 void TEEC_RequestCancellation(TEEC_Operation *operation)
 {
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
 	TEEC_Session *session = NULL;
 	struct tee_ioctl_cancel_arg arg;

@@ -755,9 +897,19 @@ void TEEC_RequestCancellation(TEEC_Operation *operation)
 	if (!operation)
 		return;

-	teec_mutex_lock(&teec_mutex);
+	// MOD: add mutex for multi-thread CA call on the same operation
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+
+	teec_mutex_lock(mutex);
 	session = operation->imp.session;
-	teec_mutex_unlock(&teec_mutex);
+	operation->imp.is_initialized = false;
+	teec_mutex_unlock(mutex);
+
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);

 	if (!session)
 		return;
@@ -774,6 +926,8 @@ TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
 	TEEC_Result res = TEEC_SUCCESS;
 	int fd = 0;
 	size_t s = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;

 	if (!ctx || !shm)
 		return TEEC_ERROR_BAD_PARAMETERS;
@@ -787,12 +941,31 @@ TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
 	s = shm->size;
 	if (!s)
 		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
 	if (ctx->imp.reg_mem) {
 		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
 		if (fd >= 0) {
 			shm->imp.registered_fd = fd;
 			shm->imp.shadow_buffer = NULL;
 			shm->imp.flags = 0;
+			shm->imp.is_initialized = true;
 			goto out;
 		}

@@ -806,13 +979,18 @@ TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
 		 * register a shadow buffer before giving up.
 		 */
 		shm->imp.shadow_buffer = teec_paged_aligned_alloc(s);
-		if (!shm->imp.shadow_buffer)
+		if (!shm->imp.shadow_buffer) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
 		fd = teec_shm_register(ctx->imp.fd, shm->imp.shadow_buffer, s,
 				       &shm->imp.id);
 		if (fd >= 0) {
 			shm->imp.registered_fd = fd;
 			shm->imp.flags = SHM_FLAG_SHADOW_BUFFER_ALLOCED;
+			shm->imp.is_initialized = true;
 			goto out;
 		}

@@ -822,25 +1000,39 @@ TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
 			res = TEEC_ERROR_GENERIC;
 		free(shm->imp.shadow_buffer);
 		shm->imp.shadow_buffer = NULL;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+		TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 		return res;
 	} else {
 		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
-		if (fd < 0)
+		if (fd < 0) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 			return TEEC_ERROR_OUT_OF_MEMORY;
+		}

 		shm->imp.shadow_buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
 					  MAP_SHARED, fd, 0);
 		close(fd);
 		if (shm->imp.shadow_buffer == (void *)MAP_FAILED) {
 			shm->imp.id = -1;
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 			return TEEC_ERROR_OUT_OF_MEMORY;
 		}
 		shm->imp.registered_fd = -1;
 		shm->imp.flags = 0;
+		shm->imp.is_initialized = true;
 	}

 out:
 	shm->imp.alloced_size = s;
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 	return TEEC_SUCCESS;
 }

@@ -848,6 +1040,8 @@ TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,
 						    TEEC_SharedMemory *shm,
 						    int fd)
 {
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
 	int rfd = 0;
 	struct tee_ioctl_shm_register_fd_data data;

@@ -864,11 +1058,35 @@ TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,
 	if (rfd < 0)
 		return TEEC_ERROR_BAD_PARAMETERS;

+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
 	shm->buffer = NULL;
 	shm->imp.shadow_buffer = NULL;
 	shm->imp.registered_fd = rfd;
 	shm->imp.id = data.id;
 	shm->size = data.size;
+	shm->imp.is_initialized = true;
+	goto out;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 	return TEEC_SUCCESS;
 }

@@ -876,6 +1094,9 @@ TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
 {
 	int fd = 0;
 	size_t s = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Result res = TEEC_SUCCESS;

 	if (!ctx || !shm)
 		return TEEC_ERROR_BAD_PARAMETERS;
@@ -887,29 +1108,52 @@ TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
 	if (!s)
 		s = 8;

+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
 	if (ctx->imp.reg_mem) {
 		shm->buffer = teec_paged_aligned_alloc(s);
-		if (!shm->buffer)
-			return TEEC_ERROR_OUT_OF_MEMORY;
+		if (!shm->buffer) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}

 		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
 		if (fd < 0) {
 			free(shm->buffer);
 			shm->buffer = NULL;
-			return TEEC_ERROR_OUT_OF_MEMORY;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
 		}
 		shm->imp.registered_fd = fd;
 	} else {
 		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
-		if (fd < 0)
-			return TEEC_ERROR_OUT_OF_MEMORY;
+		if (fd < 0) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}

 		shm->buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
 				   MAP_SHARED, fd, 0);
 		close(fd);
 		if (shm->buffer == (void *)MAP_FAILED) {
 			shm->imp.id = -1;
-			return TEEC_ERROR_OUT_OF_MEMORY;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
 		}
 		shm->imp.registered_fd = -1;
 	}
@@ -917,14 +1161,37 @@ TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
 	shm->imp.shadow_buffer = NULL;
 	shm->imp.alloced_size = s;
 	shm->imp.flags = SHM_FLAG_BUFFER_ALLOCED;
-	return TEEC_SUCCESS;
+	shm->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+
+	return res;
 }

 void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
 {
-	if (!shm || shm->imp.id == -1)
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!shm)
 		return;

+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (shm->imp.id == -1 || !shm->imp.is_initialized) {
+		goto out;
+	}
+
 	if (shm->imp.shadow_buffer) {
 		if (shm->imp.registered_fd >= 0) {
 			if (shm->imp.flags &
@@ -951,4 +1218,10 @@ void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
 	shm->buffer = NULL;
 	shm->imp.registered_fd = -1;
 	shm->imp.flags = 0;
+	shm->imp.is_initialized = false;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
 }
diff --git a/libteec/src/tee_client_api_final.c b/libteec/src/tee_client_api_final.c
new file mode 100644
index 0000000..66920bb
--- /dev/null
+++ b/libteec/src/tee_client_api_final.c
@@ -0,0 +1,1227 @@
+/*
+ * Copyright (c) 2015-2016, Linaro Limited
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <tee_client_api_extensions.h>
+#include <tee_client_api.h>
+#include <teec_mutex_pool.h>
+#include <teec_trace.h>
+#include <unistd.h>
+
+#ifndef __aligned
+#define __aligned(x) __attribute__((__aligned__(x)))
+#endif
+#include <linux/tee.h>
+
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
+/* How many device sequence numbers will be tried before giving up */
+#define TEEC_MAX_DEV_SEQ	10
+
+/* Helpers to access memref parts of a struct tee_ioctl_param */
+#define MEMREF_SHM_ID(p)	((p)->c)
+#define MEMREF_SHM_OFFS(p)	((p)->a)
+#define MEMREF_SIZE(p)		((p)->b)
+
+/*
+ * Internal flags of TEEC_SharedMemory::internal.flags
+ */
+#define SHM_FLAG_BUFFER_ALLOCED		(1u << 0)
+#define SHM_FLAG_SHADOW_BUFFER_ALLOCED	(1u << 1)
+
+static pthread_mutex_t teec_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex for shared memory
+static pthread_mutex_t teec_shm_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex pool
+static TEEC_Mutex_Pool teec_mutex_pool = { .key = {0}, .val = {PTHREAD_MUTEX_INITIALIZER} };
+
+static void teec_mutex_lock(pthread_mutex_t *mu)
+{
+	pthread_mutex_lock(mu);
+}
+
+static void teec_mutex_unlock(pthread_mutex_t *mu)
+{
+	pthread_mutex_unlock(mu);
+}
+
+static void *teec_paged_aligned_alloc(size_t sz)
+{
+	void *p = NULL;
+	size_t page_sz = sysconf(_SC_PAGESIZE);
+	size_t aligned_sz = ((sz + page_sz - 1) / page_sz) * page_sz;
+
+	if (aligned_sz >= sz && !posix_memalign(&p, page_sz, aligned_sz))
+		return p;
+
+	return NULL;
+}
+
+static int teec_open_dev(const char *devname, const char *capabilities,
+			 uint32_t *gen_caps)
+{
+	int fd = 0;
+	struct tee_ioctl_version_data vers;
+
+	memset(&vers, 0, sizeof(vers));
+
+	fd = open(devname, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	if (ioctl(fd, TEE_IOC_VERSION, &vers)) {
+		EMSG("TEE_IOC_VERSION failed");
+		goto err;
+	}
+
+	/* We can only handle GP TEEs */
+	if (!(vers.gen_caps & TEE_GEN_CAP_GP))
+		goto err;
+
+	if (capabilities) {
+		if (strcmp(capabilities, "optee-tz") == 0) {
+			if (vers.impl_id != TEE_IMPL_ID_OPTEE)
+				goto err;
+			if (!(vers.impl_caps & TEE_OPTEE_CAP_TZ))
+				goto err;
+		} else {
+			/* Unrecognized capability requested */
+			goto err;
+		}
+	}
+
+	*gen_caps = vers.gen_caps;
+	return fd;
+err:
+	close(fd);
+	return -1;
+}
+
+static int teec_shm_alloc(int fd, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_alloc_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.size = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_ALLOC, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+static int teec_shm_register(int fd, void *buf, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_register_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.addr = (uintptr_t)buf;
+	data.length = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_REGISTER, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)
+{
+	char devname[PATH_MAX] = { 0 };
+	int fd = 0;
+	size_t n = 0;
+
+	if (!ctx)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: avoid initializing an ctx more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the ctx object to be initialized with 0
+	*/
+	// teec_mutex_lock(&teec_mutex);
+	// if (ctx->imp.is_initialized) {
+	// 	teec_mutex_unlock(&teec_mutex);
+	// 	return TEEC_ERROR_BAD_PARAMETERS;
+	// }
+	// teec_mutex_unlock(&teec_mutex);
+
+	for (n = 0; n < TEEC_MAX_DEV_SEQ; n++) {
+		uint32_t gen_caps = 0;
+
+		snprintf(devname, sizeof(devname), "/dev/tee%zu", n);
+		fd = teec_open_dev(devname, name, &gen_caps);
+		if (fd >= 0) {
+			// MOD: add mutex for multi-thread CA call on the same ctx
+			teec_mutex_lock(&teec_mutex);
+			ctx->imp.fd = fd;
+			ctx->imp.reg_mem = gen_caps & TEE_GEN_CAP_REG_MEM;
+			ctx->imp.memref_null = gen_caps & TEE_GEN_CAP_MEMREF_NULL;
+			ctx->imp.is_initialized = true;
+			// MOD: release mutex
+			teec_mutex_unlock(&teec_mutex);
+			return TEEC_SUCCESS;
+		}
+	}
+
+	return TEEC_ERROR_ITEM_NOT_FOUND;
+}
+
+void TEEC_FinalizeContext(TEEC_Context *ctx)
+{
+	if (ctx) {
+		// MOD: add mutex for multi-thread CA call on the same ctx
+		teec_mutex_lock(&teec_mutex);
+		// MOD: avoid finalizing an uninitialized ctx
+		if (ctx->imp.is_initialized) {
+			close(ctx->imp.fd);
+			ctx->imp.is_initialized = false;
+		}
+		// MOD: release mutex
+		teec_mutex_unlock(&teec_mutex);
+	}
+}
+
+
+static TEEC_Result teec_pre_process_tmpref(TEEC_Context *ctx,
+			uint32_t param_type, TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+
+	switch (param_type) {
+	case TEEC_MEMREF_TEMP_INPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		shm->flags = TEEC_MEM_INPUT;
+		break;
+	case TEEC_MEMREF_TEMP_OUTPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		shm->flags = TEEC_MEM_OUTPUT;
+		break;
+	case TEEC_MEMREF_TEMP_INOUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		shm->flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+	shm->size = tmpref->size;
+
+	if (!tmpref->buffer) {
+		if (tmpref->size)
+			return TEEC_ERROR_BAD_PARAMETERS;
+
+		if (ctx->imp.memref_null) {
+			/* Null pointer, indicate no shared memory attached */
+			MEMREF_SHM_ID(param) = TEE_MEMREF_NULL;
+			shm->imp.id = -1;
+		} else {
+			res = TEEC_AllocateSharedMemory(ctx, shm);
+			if (res != TEEC_SUCCESS)
+				return res;
+			MEMREF_SHM_ID(param) = shm->imp.id;
+		}
+	} else {
+		shm->buffer = tmpref->buffer;
+		res = TEEC_RegisterSharedMemory(ctx, shm);
+		if (res != TEEC_SUCCESS)
+			return res;
+
+		if (shm->imp.shadow_buffer)
+			memcpy(shm->imp.shadow_buffer, tmpref->buffer,
+			       tmpref->size);
+
+		MEMREF_SHM_ID(param) = shm->imp.id;
+	}
+
+	MEMREF_SIZE(param) = tmpref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_whole(
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	const uint32_t inout = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+	uint32_t flags = memref->parent->flags & inout;
+	TEEC_SharedMemory *shm = NULL;
+
+	if (flags == inout)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+	else if (flags & TEEC_MEM_INPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	else if (flags & TEEC_MEM_OUTPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+	else
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	shm = memref->parent;
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && (flags & TEEC_MEM_INPUT))
+		memcpy(shm->imp.shadow_buffer, shm->buffer, shm->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SIZE(param) = shm->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	uint32_t req_shm_flags = 0;
+	TEEC_SharedMemory *shm = NULL;
+
+	switch (param_type) {
+	case TEEC_MEMREF_PARTIAL_INPUT:
+		req_shm_flags = TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_OUTPUT:
+		req_shm_flags = TEEC_MEM_OUTPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_INOUT:
+		req_shm_flags = TEEC_MEM_OUTPUT | TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	shm = memref->parent;
+
+	if ((shm->flags & req_shm_flags) != req_shm_flags)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if ((memref->offset + memref->size < memref->offset) ||
+	    (memref->offset + memref->size > shm->size))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && param_type != TEEC_MEMREF_PARTIAL_OUTPUT)
+		memcpy((char *)shm->imp.shadow_buffer + memref->offset,
+		       (char *)shm->buffer + memref->offset, memref->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SHM_OFFS(param) = memref->offset;
+	MEMREF_SIZE(param) = memref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
+			TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	memset(shms, 0, sizeof(TEEC_SharedMemory) *
+			TEEC_CONFIG_PAYLOAD_REF_COUNT);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++)
+		shms[n].imp.id = -1;
+
+	if (!operation) {
+		memset(params, 0, sizeof(struct tee_ioctl_param) *
+				  TEEC_CONFIG_PAYLOAD_REF_COUNT);
+		return TEEC_SUCCESS;
+	}
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing an operation more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the operation object to be initialized with 0
+	*/
+	// if (operation->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_NONE:
+			params[n].attr = param_type;
+			break;
+		case TEEC_VALUE_INPUT:
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			params[n].attr = param_type;
+			params[n].a = operation->params[n].value.a;
+			params[n].b = operation->params[n].value.b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			res = teec_pre_process_tmpref(ctx, param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_WHOLE:
+			res = teec_pre_process_whole(
+					&operation->params[n].memref,
+					params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			res = teec_pre_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		default:
+			res = TEEC_ERROR_BAD_PARAMETERS;
+			goto out;
+		}
+	}
+	operation->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	return res;
+}
+
+static void teec_post_process_tmpref(uint32_t param_type,
+			TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	if (param_type != TEEC_MEMREF_TEMP_INPUT) {
+		if (tmpref->buffer && shm->imp.shadow_buffer)
+			memcpy(tmpref->buffer, shm->imp.shadow_buffer,
+			       MIN(MEMREF_SIZE(param), tmpref->size));
+
+		tmpref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_whole(TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	TEEC_SharedMemory *shm = memref->parent;
+
+	if (shm->flags & TEEC_MEM_OUTPUT) {
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= shm->size)
+			memcpy(shm->buffer, shm->imp.shadow_buffer,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	if (param_type != TEEC_MEMREF_PARTIAL_INPUT) {
+		TEEC_SharedMemory *shm = memref->parent;
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= memref->size)
+			memcpy((char *)shm->buffer + memref->offset,
+			       (char *)shm->imp.shadow_buffer + memref->offset,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_operation(TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (!operation->imp.is_initialized) {
+		goto out;
+	}
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_VALUE_INPUT:
+			break;
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			operation->params[n].value.a = params[n].a;
+			operation->params[n].value.b = params[n].b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			teec_post_process_tmpref(param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			break;
+		case TEEC_MEMREF_WHOLE:
+			teec_post_process_whole(&operation->params[n].memref,
+						params + n);
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			teec_post_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+		default:
+			break;
+		}
+	}
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+}
+
+static void teec_free_temp_refs(TEEC_Operation *operation,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		switch (TEEC_PARAM_TYPE_GET(operation->paramTypes, n)) {
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			TEEC_ReleaseSharedMemory(shms + n);
+			break;
+		default:
+			break;
+		}
+	}
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+}
+
+static TEEC_Result ioctl_errno_to_res(int err)
+{
+	switch (err) {
+	case ENOMEM:
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	case EINVAL:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	default:
+		return TEEC_ERROR_GENERIC;
+	}
+}
+
+static void uuid_to_octets(uint8_t d[TEE_IOCTL_UUID_LEN], const TEEC_UUID *s)
+{
+	d[0] = s->timeLow >> 24;
+	d[1] = s->timeLow >> 16;
+	d[2] = s->timeLow >> 8;
+	d[3] = s->timeLow;
+	d[4] = s->timeMid >> 8;
+	d[5] = s->timeMid;
+	d[6] = s->timeHiAndVersion >> 8;
+	d[7] = s->timeHiAndVersion;
+	memcpy(d + 8, s->clockSeqAndNode, sizeof(s->clockSeqAndNode));
+}
+
+static void setup_client_data(struct tee_ioctl_open_session_arg *arg,
+			      uint32_t connection_method,
+			      const void *connection_data)
+{
+	arg->clnt_login = connection_method;
+
+	switch (connection_method) {
+	case TEE_IOCTL_LOGIN_PUBLIC:
+		/* No connection data to pass */
+		break;
+	case TEE_IOCTL_LOGIN_USER:
+		/* Kernel auto-fills UID and forms client UUID */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP:
+		/*
+		 * Connection data for group login is uint32_t and rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	case TEE_IOCTL_LOGIN_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier and forms client
+		 * UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_USER_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier, UID and forms
+		 * client UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP_APPLICATION:
+		/*
+		 * Connection data for group login is uint32_t rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership, auto-fills application
+		 * identifier and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	default:
+		/*
+		 * Unknown login method, don't pass any connection data as we
+		 * don't know size.
+		 */
+		break;
+	}
+}
+
+TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,
+			const TEEC_UUID *destination,
+			uint32_t connection_method, const void *connection_data,
+			TEEC_Operation *operation, uint32_t *ret_origin)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_open_session_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_open_session_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_open_session_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&shm, 0, sizeof(shm));
+	memset(&buf_data, 0, sizeof(buf_data));
+
+	if (!ctx || !session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	key = ADDR_TO_KEY(session);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		// eorig = TEEC_ORIGIN_API;
+		// res = TEEC_ERROR_BUSY;
+		// goto out;
+		mutex = &teec_mutex;
+	}
+
+	// MOD: avoid initializing a session more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the session object to be initialized with 0
+	*/
+	// teec_mutex_lock(mutex);
+	// if (session->imp.is_initialized) {
+	// 	teec_mutex_unlock(mutex);
+	// 	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	// 	eorig = TEEC_ORIGIN_API;
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+	// teec_mutex_unlock(mutex);
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	uuid_to_octets(arg->uuid, destination);
+
+	setup_client_data(arg, connection_method, connection_data);
+
+	res = teec_pre_process_operation(ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(ctx->imp.fd, TEE_IOC_OPEN_SESSION, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_OPEN_SESSION failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	if (res == TEEC_SUCCESS) {
+		// MOD: add mutex for multi-thread CA call on the same session
+		teec_mutex_lock(mutex);
+		session->imp.ctx = ctx;
+		session->imp.session_id = arg->session;
+		session->imp.is_initialized = true;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+	}
+	teec_post_process_operation(operation, params, shm);
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+out:
+	if (ret_origin)
+		*ret_origin = eorig;
+	return res;
+}
+
+void TEEC_CloseSession(TEEC_Session *session)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_close_session_arg arg;
+	int rc = 0;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!session)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	key = ADDR_TO_KEY(session);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid close an uninitialized session
+	if (session->imp.is_initialized) {
+		arg.session = session->imp.session_id;
+		rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_CLOSE_SESSION, &arg);
+		if (!rc) {
+			session->imp.is_initialized = false;
+		}
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+
+	if (rc)
+		EMSG("Failed to close session 0x%x", session->imp.session_id);
+}
+
+TEEC_Result TEEC_InvokeCommand(TEEC_Session *session, uint32_t cmd_id,
+			TEEC_Operation *operation, uint32_t *error_origin)
+{
+	struct tee_ioctl_invoke_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_invoke_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_invoke_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&buf_data, 0, sizeof(buf_data));
+	memset(&shm, 0, sizeof(shm));
+
+	if (!session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	arg->session = session->imp.session_id;
+	arg->func = cmd_id;
+
+	if (operation) {
+		teec_mutex_lock(&teec_mutex);
+		operation->imp.session = session;
+		teec_mutex_unlock(&teec_mutex);
+	}
+
+	res = teec_pre_process_operation(session->imp.ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_INVOKE, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_INVOKE failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	teec_post_process_operation(operation, params, shm);
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+out:
+	if (error_origin)
+		*error_origin = eorig;
+	return res;
+}
+
+void TEEC_RequestCancellation(TEEC_Operation *operation)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Session *session = NULL;
+	struct tee_ioctl_cancel_arg arg;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!operation)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same operation
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+
+	teec_mutex_lock(mutex);
+	session = operation->imp.session;
+	operation->imp.is_initialized = false;
+	teec_mutex_unlock(mutex);
+
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+
+	if (!session)
+		return;
+
+	arg.session = session->imp.session_id;
+	arg.cancel_id = 0;
+
+	if (ioctl(session->imp.ctx->imp.fd, TEE_IOC_CANCEL, &arg))
+		EMSG("TEE_IOC_CANCEL: %s", strerror(errno));
+}
+
+TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	int fd = 0;
+	size_t s = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->buffer)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.shadow_buffer = NULL;
+			shm->imp.flags = 0;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		/*
+		 * If we're here TEE_IOC_SHM_REGISTER failed, probably
+		 * because some read-only memory was supplied and the Linux
+		 * kernel doesn't like that at the moment.
+		 *
+		 * The error could also have some other origin. In any case
+		 * we're not making matters worse by trying to allocate and
+		 * register a shadow buffer before giving up.
+		 */
+		shm->imp.shadow_buffer = teec_paged_aligned_alloc(s);
+		if (!shm->imp.shadow_buffer) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		fd = teec_shm_register(ctx->imp.fd, shm->imp.shadow_buffer, s,
+				       &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.flags = SHM_FLAG_SHADOW_BUFFER_ALLOCED;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		if (errno == ENOMEM)
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+		else
+			res = TEEC_ERROR_GENERIC;
+		free(shm->imp.shadow_buffer);
+		shm->imp.shadow_buffer = NULL;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+		TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+		return res;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+
+		shm->imp.shadow_buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+					  MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->imp.shadow_buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		shm->imp.registered_fd = -1;
+		shm->imp.flags = 0;
+		shm->imp.is_initialized = true;
+	}
+
+out:
+	shm->imp.alloced_size = s;
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,
+						    TEEC_SharedMemory *shm,
+						    int fd)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	int rfd = 0;
+	struct tee_ioctl_shm_register_fd_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	if (!ctx || !shm || fd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	data.fd = fd;
+	rfd = ioctl(ctx->imp.fd, TEE_IOC_SHM_REGISTER_FD, &data);
+	if (rfd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	shm->buffer = NULL;
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.registered_fd = rfd;
+	shm->imp.id = data.id;
+	shm->size = data.size;
+	shm->imp.is_initialized = true;
+	goto out;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	int fd = 0;
+	size_t s = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Result res = TEEC_SUCCESS;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		shm->buffer = teec_paged_aligned_alloc(s);
+		if (!shm->buffer) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd < 0) {
+			free(shm->buffer);
+			shm->buffer = NULL;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = fd;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		shm->buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+				   MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = -1;
+	}
+
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.alloced_size = s;
+	shm->imp.flags = SHM_FLAG_BUFFER_ALLOCED;
+	shm->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+
+	return res;
+}
+
+void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!shm)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (shm->imp.id == -1 || !shm->imp.is_initialized) {
+		goto out;
+	}
+
+	if (shm->imp.shadow_buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags &
+			    SHM_FLAG_SHADOW_BUFFER_ALLOCED)
+				free(shm->imp.shadow_buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->imp.shadow_buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags & SHM_FLAG_BUFFER_ALLOCED)
+				free(shm->buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->imp.registered_fd >= 0) {
+		close(shm->imp.registered_fd);
+	}
+
+	shm->imp.id = -1;
+	shm->imp.shadow_buffer = NULL;
+	shm->buffer = NULL;
+	shm->imp.registered_fd = -1;
+	shm->imp.flags = 0;
+	shm->imp.is_initialized = false;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+}
diff --git a/libteec/src/tee_client_api_global.c b/libteec/src/tee_client_api_global.c
new file mode 100644
index 0000000..b1165ab
--- /dev/null
+++ b/libteec/src/tee_client_api_global.c
@@ -0,0 +1,1162 @@
+/*
+ * Copyright (c) 2015-2016, Linaro Limited
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <tee_client_api_extensions.h>
+#include <tee_client_api.h>
+#include <teec_mutex_pool.h>
+#include <teec_trace.h>
+#include <unistd.h>
+
+#ifndef __aligned
+#define __aligned(x) __attribute__((__aligned__(x)))
+#endif
+#include <linux/tee.h>
+
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
+/* How many device sequence numbers will be tried before giving up */
+#define TEEC_MAX_DEV_SEQ	10
+
+/* Helpers to access memref parts of a struct tee_ioctl_param */
+#define MEMREF_SHM_ID(p)	((p)->c)
+#define MEMREF_SHM_OFFS(p)	((p)->a)
+#define MEMREF_SIZE(p)		((p)->b)
+
+/*
+ * Internal flags of TEEC_SharedMemory::internal.flags
+ */
+#define SHM_FLAG_BUFFER_ALLOCED		(1u << 0)
+#define SHM_FLAG_SHADOW_BUFFER_ALLOCED	(1u << 1)
+
+static pthread_mutex_t teec_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex for shared memory
+static pthread_mutex_t teec_shm_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static void teec_mutex_lock(pthread_mutex_t *mu)
+{
+	pthread_mutex_lock(mu);
+}
+
+static void teec_mutex_unlock(pthread_mutex_t *mu)
+{
+	pthread_mutex_unlock(mu);
+}
+
+static void *teec_paged_aligned_alloc(size_t sz)
+{
+	void *p = NULL;
+	size_t page_sz = sysconf(_SC_PAGESIZE);
+	size_t aligned_sz = ((sz + page_sz - 1) / page_sz) * page_sz;
+
+	if (aligned_sz >= sz && !posix_memalign(&p, page_sz, aligned_sz))
+		return p;
+
+	return NULL;
+}
+
+static int teec_open_dev(const char *devname, const char *capabilities,
+			 uint32_t *gen_caps)
+{
+	int fd = 0;
+	struct tee_ioctl_version_data vers;
+
+	memset(&vers, 0, sizeof(vers));
+
+	fd = open(devname, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	if (ioctl(fd, TEE_IOC_VERSION, &vers)) {
+		EMSG("TEE_IOC_VERSION failed");
+		goto err;
+	}
+
+	/* We can only handle GP TEEs */
+	if (!(vers.gen_caps & TEE_GEN_CAP_GP))
+		goto err;
+
+	if (capabilities) {
+		if (strcmp(capabilities, "optee-tz") == 0) {
+			if (vers.impl_id != TEE_IMPL_ID_OPTEE)
+				goto err;
+			if (!(vers.impl_caps & TEE_OPTEE_CAP_TZ))
+				goto err;
+		} else {
+			/* Unrecognized capability requested */
+			goto err;
+		}
+	}
+
+	*gen_caps = vers.gen_caps;
+	return fd;
+err:
+	close(fd);
+	return -1;
+}
+
+static int teec_shm_alloc(int fd, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_alloc_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.size = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_ALLOC, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+static int teec_shm_register(int fd, void *buf, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_register_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.addr = (uintptr_t)buf;
+	data.length = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_REGISTER, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)
+{
+	char devname[PATH_MAX] = { 0 };
+	int fd = 0;
+	size_t n = 0;
+
+	if (!ctx)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: avoid initializing an ctx more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the ctx object to be initialized with 0
+	*/
+	// teec_mutex_lock(&teec_mutex);
+	// if (ctx->imp.is_initialized) {
+	// 	teec_mutex_unlock(&teec_mutex);
+	// 	return TEEC_ERROR_BAD_PARAMETERS;
+	// }
+	// teec_mutex_unlock(&teec_mutex);
+
+	for (n = 0; n < TEEC_MAX_DEV_SEQ; n++) {
+		uint32_t gen_caps = 0;
+
+		snprintf(devname, sizeof(devname), "/dev/tee%zu", n);
+		fd = teec_open_dev(devname, name, &gen_caps);
+		if (fd >= 0) {
+			// MOD: add mutex for multi-thread CA call on the same ctx
+			teec_mutex_lock(&teec_mutex);
+			ctx->imp.fd = fd;
+			ctx->imp.reg_mem = gen_caps & TEE_GEN_CAP_REG_MEM;
+			ctx->imp.memref_null = gen_caps & TEE_GEN_CAP_MEMREF_NULL;
+			ctx->imp.is_initialized = true;
+			// MOD: release mutex
+			teec_mutex_unlock(&teec_mutex);
+			return TEEC_SUCCESS;
+		}
+	}
+
+	return TEEC_ERROR_ITEM_NOT_FOUND;
+}
+
+void TEEC_FinalizeContext(TEEC_Context *ctx)
+{
+	if (ctx) {
+		// MOD: add mutex for multi-thread CA call on the same ctx
+		teec_mutex_lock(&teec_mutex);
+		// MOD: avoid finalizing an uninitialized ctx
+		if (ctx->imp.is_initialized) {
+			close(ctx->imp.fd);
+			ctx->imp.is_initialized = false;
+		}
+		// MOD: release mutex
+		teec_mutex_unlock(&teec_mutex);
+	}
+}
+
+
+static TEEC_Result teec_pre_process_tmpref(TEEC_Context *ctx,
+			uint32_t param_type, TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+
+	switch (param_type) {
+	case TEEC_MEMREF_TEMP_INPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		shm->flags = TEEC_MEM_INPUT;
+		break;
+	case TEEC_MEMREF_TEMP_OUTPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		shm->flags = TEEC_MEM_OUTPUT;
+		break;
+	case TEEC_MEMREF_TEMP_INOUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		shm->flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+	shm->size = tmpref->size;
+
+	if (!tmpref->buffer) {
+		if (tmpref->size)
+			return TEEC_ERROR_BAD_PARAMETERS;
+
+		if (ctx->imp.memref_null) {
+			/* Null pointer, indicate no shared memory attached */
+			MEMREF_SHM_ID(param) = TEE_MEMREF_NULL;
+			shm->imp.id = -1;
+		} else {
+			res = TEEC_AllocateSharedMemory(ctx, shm);
+			if (res != TEEC_SUCCESS)
+				return res;
+			MEMREF_SHM_ID(param) = shm->imp.id;
+		}
+	} else {
+		shm->buffer = tmpref->buffer;
+		res = TEEC_RegisterSharedMemory(ctx, shm);
+		if (res != TEEC_SUCCESS)
+			return res;
+
+		if (shm->imp.shadow_buffer)
+			memcpy(shm->imp.shadow_buffer, tmpref->buffer,
+			       tmpref->size);
+
+		MEMREF_SHM_ID(param) = shm->imp.id;
+	}
+
+	MEMREF_SIZE(param) = tmpref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_whole(
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	const uint32_t inout = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+	uint32_t flags = memref->parent->flags & inout;
+	TEEC_SharedMemory *shm = NULL;
+
+	if (flags == inout)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+	else if (flags & TEEC_MEM_INPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	else if (flags & TEEC_MEM_OUTPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+	else
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	shm = memref->parent;
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && (flags & TEEC_MEM_INPUT))
+		memcpy(shm->imp.shadow_buffer, shm->buffer, shm->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SIZE(param) = shm->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	uint32_t req_shm_flags = 0;
+	TEEC_SharedMemory *shm = NULL;
+
+	switch (param_type) {
+	case TEEC_MEMREF_PARTIAL_INPUT:
+		req_shm_flags = TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_OUTPUT:
+		req_shm_flags = TEEC_MEM_OUTPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_INOUT:
+		req_shm_flags = TEEC_MEM_OUTPUT | TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	shm = memref->parent;
+
+	if ((shm->flags & req_shm_flags) != req_shm_flags)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if ((memref->offset + memref->size < memref->offset) ||
+	    (memref->offset + memref->size > shm->size))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && param_type != TEEC_MEMREF_PARTIAL_OUTPUT)
+		memcpy((char *)shm->imp.shadow_buffer + memref->offset,
+		       (char *)shm->buffer + memref->offset, memref->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SHM_OFFS(param) = memref->offset;
+	MEMREF_SIZE(param) = memref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
+			TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	size_t n = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	memset(shms, 0, sizeof(TEEC_SharedMemory) *
+			TEEC_CONFIG_PAYLOAD_REF_COUNT);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++)
+		shms[n].imp.id = -1;
+
+	if (!operation) {
+		memset(params, 0, sizeof(struct tee_ioctl_param) *
+				  TEEC_CONFIG_PAYLOAD_REF_COUNT);
+		return TEEC_SUCCESS;
+	}
+
+	mutex = &teec_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing an operation more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the operation object to be initialized with 0
+	*/
+	// if (operation->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_NONE:
+			params[n].attr = param_type;
+			break;
+		case TEEC_VALUE_INPUT:
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			params[n].attr = param_type;
+			params[n].a = operation->params[n].value.a;
+			params[n].b = operation->params[n].value.b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			res = teec_pre_process_tmpref(ctx, param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_WHOLE:
+			res = teec_pre_process_whole(
+					&operation->params[n].memref,
+					params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			res = teec_pre_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		default:
+			res = TEEC_ERROR_BAD_PARAMETERS;
+			goto out;
+		}
+	}
+	operation->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	return res;
+}
+
+static void teec_post_process_tmpref(uint32_t param_type,
+			TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	if (param_type != TEEC_MEMREF_TEMP_INPUT) {
+		if (tmpref->buffer && shm->imp.shadow_buffer)
+			memcpy(tmpref->buffer, shm->imp.shadow_buffer,
+			       MIN(MEMREF_SIZE(param), tmpref->size));
+
+		tmpref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_whole(TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	TEEC_SharedMemory *shm = memref->parent;
+
+	if (shm->flags & TEEC_MEM_OUTPUT) {
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= shm->size)
+			memcpy(shm->buffer, shm->imp.shadow_buffer,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	if (param_type != TEEC_MEMREF_PARTIAL_INPUT) {
+		TEEC_SharedMemory *shm = memref->parent;
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= memref->size)
+			memcpy((char *)shm->buffer + memref->offset,
+			       (char *)shm->imp.shadow_buffer + memref->offset,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_operation(TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	mutex = &teec_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (!operation->imp.is_initialized) {
+		goto out;
+	}
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_VALUE_INPUT:
+			break;
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			operation->params[n].value.a = params[n].a;
+			operation->params[n].value.b = params[n].b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			teec_post_process_tmpref(param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			break;
+		case TEEC_MEMREF_WHOLE:
+			teec_post_process_whole(&operation->params[n].memref,
+						params + n);
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			teec_post_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+		default:
+			break;
+		}
+	}
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+}
+
+static void teec_free_temp_refs(TEEC_Operation *operation,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	mutex = &teec_mutex;
+	teec_mutex_lock(mutex);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		switch (TEEC_PARAM_TYPE_GET(operation->paramTypes, n)) {
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			TEEC_ReleaseSharedMemory(shms + n);
+			break;
+		default:
+			break;
+		}
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+}
+
+static TEEC_Result ioctl_errno_to_res(int err)
+{
+	switch (err) {
+	case ENOMEM:
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	case EINVAL:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	default:
+		return TEEC_ERROR_GENERIC;
+	}
+}
+
+static void uuid_to_octets(uint8_t d[TEE_IOCTL_UUID_LEN], const TEEC_UUID *s)
+{
+	d[0] = s->timeLow >> 24;
+	d[1] = s->timeLow >> 16;
+	d[2] = s->timeLow >> 8;
+	d[3] = s->timeLow;
+	d[4] = s->timeMid >> 8;
+	d[5] = s->timeMid;
+	d[6] = s->timeHiAndVersion >> 8;
+	d[7] = s->timeHiAndVersion;
+	memcpy(d + 8, s->clockSeqAndNode, sizeof(s->clockSeqAndNode));
+}
+
+static void setup_client_data(struct tee_ioctl_open_session_arg *arg,
+			      uint32_t connection_method,
+			      const void *connection_data)
+{
+	arg->clnt_login = connection_method;
+
+	switch (connection_method) {
+	case TEE_IOCTL_LOGIN_PUBLIC:
+		/* No connection data to pass */
+		break;
+	case TEE_IOCTL_LOGIN_USER:
+		/* Kernel auto-fills UID and forms client UUID */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP:
+		/*
+		 * Connection data for group login is uint32_t and rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	case TEE_IOCTL_LOGIN_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier and forms client
+		 * UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_USER_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier, UID and forms
+		 * client UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP_APPLICATION:
+		/*
+		 * Connection data for group login is uint32_t rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership, auto-fills application
+		 * identifier and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	default:
+		/*
+		 * Unknown login method, don't pass any connection data as we
+		 * don't know size.
+		 */
+		break;
+	}
+}
+
+TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,
+			const TEEC_UUID *destination,
+			uint32_t connection_method, const void *connection_data,
+			TEEC_Operation *operation, uint32_t *ret_origin)
+{
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_open_session_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_open_session_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_open_session_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&shm, 0, sizeof(shm));
+	memset(&buf_data, 0, sizeof(buf_data));
+
+	if (!ctx || !session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	mutex = &teec_mutex;
+
+	// MOD: avoid initializing a session more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the session object to be initialized with 0
+	*/
+	// teec_mutex_lock(mutex);
+	// if (session->imp.is_initialized) {
+	// 	teec_mutex_unlock(mutex);
+	// 	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	// 	eorig = TEEC_ORIGIN_API;
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+	// teec_mutex_unlock(mutex);
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	uuid_to_octets(arg->uuid, destination);
+
+	setup_client_data(arg, connection_method, connection_data);
+
+	res = teec_pre_process_operation(ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(ctx->imp.fd, TEE_IOC_OPEN_SESSION, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_OPEN_SESSION failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	if (res == TEEC_SUCCESS) {
+		// MOD: add mutex for multi-thread CA call on the same session
+		teec_mutex_lock(mutex);
+		session->imp.ctx = ctx;
+		session->imp.session_id = arg->session;
+		session->imp.is_initialized = true;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+	}
+	teec_post_process_operation(operation, params, shm);
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+out:
+	if (ret_origin)
+		*ret_origin = eorig;
+	return res;
+}
+
+void TEEC_CloseSession(TEEC_Session *session)
+{
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_close_session_arg arg;
+	int rc = 0;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!session)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	mutex = &teec_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid close an uninitialized session
+	if (session->imp.is_initialized) {
+		arg.session = session->imp.session_id;
+		rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_CLOSE_SESSION, &arg);
+		if (!rc) {
+			session->imp.is_initialized = false;
+		}
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+
+	if (rc)
+		EMSG("Failed to close session 0x%x", session->imp.session_id);
+}
+
+TEEC_Result TEEC_InvokeCommand(TEEC_Session *session, uint32_t cmd_id,
+			TEEC_Operation *operation, uint32_t *error_origin)
+{
+	struct tee_ioctl_invoke_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_invoke_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_invoke_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&buf_data, 0, sizeof(buf_data));
+	memset(&shm, 0, sizeof(shm));
+
+	if (!session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	arg->session = session->imp.session_id;
+	arg->func = cmd_id;
+
+	if (operation) {
+		teec_mutex_lock(&teec_mutex);
+		operation->imp.session = session;
+		teec_mutex_unlock(&teec_mutex);
+	}
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = sizeof(teec_shm_mutex) + sizeof(teec_mutex);
+	operation->params[3].value.a = mutex_mem;
+
+	res = teec_pre_process_operation(session->imp.ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_INVOKE, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_INVOKE failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	teec_post_process_operation(operation, params, shm);
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+out:
+	if (error_origin)
+		*error_origin = eorig;
+	return res;
+}
+
+void TEEC_RequestCancellation(TEEC_Operation *operation)
+{
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Session *session = NULL;
+	struct tee_ioctl_cancel_arg arg;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!operation)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same operation
+	mutex = &teec_mutex;
+
+	teec_mutex_lock(mutex);
+	session = operation->imp.session;
+	operation->imp.is_initialized = false;
+	teec_mutex_unlock(mutex);
+
+	if (!session)
+		return;
+
+	arg.session = session->imp.session_id;
+	arg.cancel_id = 0;
+
+	if (ioctl(session->imp.ctx->imp.fd, TEE_IOC_CANCEL, &arg))
+		EMSG("TEE_IOC_CANCEL: %s", strerror(errno));
+}
+
+TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	int fd = 0;
+	size_t s = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->buffer)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	mutex = &teec_shm_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.shadow_buffer = NULL;
+			shm->imp.flags = 0;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		/*
+		 * If we're here TEE_IOC_SHM_REGISTER failed, probably
+		 * because some read-only memory was supplied and the Linux
+		 * kernel doesn't like that at the moment.
+		 *
+		 * The error could also have some other origin. In any case
+		 * we're not making matters worse by trying to allocate and
+		 * register a shadow buffer before giving up.
+		 */
+		shm->imp.shadow_buffer = teec_paged_aligned_alloc(s);
+		if (!shm->imp.shadow_buffer) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		fd = teec_shm_register(ctx->imp.fd, shm->imp.shadow_buffer, s,
+				       &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.flags = SHM_FLAG_SHADOW_BUFFER_ALLOCED;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		if (errno == ENOMEM)
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+		else
+			res = TEEC_ERROR_GENERIC;
+		free(shm->imp.shadow_buffer);
+		shm->imp.shadow_buffer = NULL;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+		return res;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+
+		shm->imp.shadow_buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+					  MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->imp.shadow_buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		shm->imp.registered_fd = -1;
+		shm->imp.flags = 0;
+		shm->imp.is_initialized = true;
+	}
+
+out:
+	shm->imp.alloced_size = s;
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,
+						    TEEC_SharedMemory *shm,
+						    int fd)
+{
+	pthread_mutex_t *mutex = NULL;
+	int rfd = 0;
+	struct tee_ioctl_shm_register_fd_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	if (!ctx || !shm || fd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	data.fd = fd;
+	rfd = ioctl(ctx->imp.fd, TEE_IOC_SHM_REGISTER_FD, &data);
+	if (rfd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	mutex = &teec_shm_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	shm->buffer = NULL;
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.registered_fd = rfd;
+	shm->imp.id = data.id;
+	shm->size = data.size;
+	shm->imp.is_initialized = true;
+	goto out;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	int fd = 0;
+	size_t s = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Result res = TEEC_SUCCESS;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	mutex = &teec_shm_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		shm->buffer = teec_paged_aligned_alloc(s);
+		if (!shm->buffer) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd < 0) {
+			free(shm->buffer);
+			shm->buffer = NULL;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = fd;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		shm->buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+				   MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = -1;
+	}
+
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.alloced_size = s;
+	shm->imp.flags = SHM_FLAG_BUFFER_ALLOCED;
+	shm->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+
+	return res;
+}
+
+void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
+{
+	pthread_mutex_t *mutex = NULL;
+
+	if (!shm)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	mutex = &teec_shm_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (shm->imp.id == -1 || !shm->imp.is_initialized) {
+		goto out;
+	}
+
+	if (shm->imp.shadow_buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags &
+			    SHM_FLAG_SHADOW_BUFFER_ALLOCED)
+				free(shm->imp.shadow_buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->imp.shadow_buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags & SHM_FLAG_BUFFER_ALLOCED)
+				free(shm->buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->imp.registered_fd >= 0) {
+		close(shm->imp.registered_fd);
+	}
+
+	shm->imp.id = -1;
+	shm->imp.shadow_buffer = NULL;
+	shm->buffer = NULL;
+	shm->imp.registered_fd = -1;
+	shm->imp.flags = 0;
+	shm->imp.is_initialized = false;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+}
diff --git a/libteec/src/tee_client_api_per_object.c b/libteec/src/tee_client_api_per_object.c
new file mode 100644
index 0000000..0be1226
--- /dev/null
+++ b/libteec/src/tee_client_api_per_object.c
@@ -0,0 +1,1263 @@
+/*
+ * Copyright (c) 2015-2016, Linaro Limited
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <tee_client_api_extensions.h>
+#include <tee_client_api.h>
+#include <teec_mutex_pool_v2.h>
+#include <teec_trace.h>
+#include <unistd.h>
+
+#ifndef __aligned
+#define __aligned(x) __attribute__((__aligned__(x)))
+#endif
+#include <linux/tee.h>
+
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
+/* How many device sequence numbers will be tried before giving up */
+#define TEEC_MAX_DEV_SEQ	10
+
+/* Helpers to access memref parts of a struct tee_ioctl_param */
+#define MEMREF_SHM_ID(p)	((p)->c)
+#define MEMREF_SHM_OFFS(p)	((p)->a)
+#define MEMREF_SIZE(p)		((p)->b)
+
+/*
+ * Internal flags of TEEC_SharedMemory::internal.flags
+ */
+#define SHM_FLAG_BUFFER_ALLOCED		(1u << 0)
+#define SHM_FLAG_SHADOW_BUFFER_ALLOCED	(1u << 1)
+
+static pthread_mutex_t teec_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex for shared memory
+static pthread_mutex_t teec_shm_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex pool
+static TEEC_Mutex_Pool_V2 teec_mutex_pool = { .capacity = 0, .size = 0, .key = NULL, .val = NULL };
+
+static void teec_mutex_lock(pthread_mutex_t *mu)
+{
+	pthread_mutex_lock(mu);
+}
+
+static void teec_mutex_unlock(pthread_mutex_t *mu)
+{
+	pthread_mutex_unlock(mu);
+}
+
+static void *teec_paged_aligned_alloc(size_t sz)
+{
+	void *p = NULL;
+	size_t page_sz = sysconf(_SC_PAGESIZE);
+	size_t aligned_sz = ((sz + page_sz - 1) / page_sz) * page_sz;
+
+	if (aligned_sz >= sz && !posix_memalign(&p, page_sz, aligned_sz))
+		return p;
+
+	return NULL;
+}
+
+static int teec_open_dev(const char *devname, const char *capabilities,
+			 uint32_t *gen_caps)
+{
+	int fd = 0;
+	struct tee_ioctl_version_data vers;
+
+	memset(&vers, 0, sizeof(vers));
+
+	fd = open(devname, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	if (ioctl(fd, TEE_IOC_VERSION, &vers)) {
+		EMSG("TEE_IOC_VERSION failed");
+		goto err;
+	}
+
+	/* We can only handle GP TEEs */
+	if (!(vers.gen_caps & TEE_GEN_CAP_GP))
+		goto err;
+
+	if (capabilities) {
+		if (strcmp(capabilities, "optee-tz") == 0) {
+			if (vers.impl_id != TEE_IMPL_ID_OPTEE)
+				goto err;
+			if (!(vers.impl_caps & TEE_OPTEE_CAP_TZ))
+				goto err;
+		} else {
+			/* Unrecognized capability requested */
+			goto err;
+		}
+	}
+
+	*gen_caps = vers.gen_caps;
+	return fd;
+err:
+	close(fd);
+	return -1;
+}
+
+static int teec_shm_alloc(int fd, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_alloc_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.size = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_ALLOC, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+static int teec_shm_register(int fd, void *buf, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_register_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.addr = (uintptr_t)buf;
+	data.length = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_REGISTER, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)
+{
+	char devname[PATH_MAX] = { 0 };
+	int fd = 0;
+	size_t n = 0;
+
+	if (!ctx)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: avoid initializing an ctx more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the ctx object to be initialized with 0
+	*/
+	// teec_mutex_lock(&teec_mutex);
+	// if (ctx->imp.is_initialized) {
+	// 	teec_mutex_unlock(&teec_mutex);
+	// 	return TEEC_ERROR_BAD_PARAMETERS;
+	// }
+	// teec_mutex_unlock(&teec_mutex);
+
+	for (n = 0; n < TEEC_MAX_DEV_SEQ; n++) {
+		uint32_t gen_caps = 0;
+
+		snprintf(devname, sizeof(devname), "/dev/tee%zu", n);
+		fd = teec_open_dev(devname, name, &gen_caps);
+		if (fd >= 0) {
+			// MOD: add mutex for multi-thread CA call on the same ctx
+			teec_mutex_lock(&teec_mutex);
+			ctx->imp.fd = fd;
+			ctx->imp.reg_mem = gen_caps & TEE_GEN_CAP_REG_MEM;
+			ctx->imp.memref_null = gen_caps & TEE_GEN_CAP_MEMREF_NULL;
+			ctx->imp.is_initialized = true;
+			// MOD: release mutex
+			teec_mutex_unlock(&teec_mutex);
+			return TEEC_SUCCESS;
+		}
+	}
+
+	return TEEC_ERROR_ITEM_NOT_FOUND;
+}
+
+void TEEC_FinalizeContext(TEEC_Context *ctx)
+{
+	if (ctx) {
+		// MOD: add mutex for multi-thread CA call on the same ctx
+		teec_mutex_lock(&teec_mutex);
+		// MOD: avoid finalizing an uninitialized ctx
+		if (ctx->imp.is_initialized) {
+			close(ctx->imp.fd);
+			ctx->imp.is_initialized = false;
+		}
+		// MOD: release mutex
+		teec_mutex_unlock(&teec_mutex);
+	}
+}
+
+
+static TEEC_Result teec_pre_process_tmpref(TEEC_Context *ctx,
+			uint32_t param_type, TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+
+	switch (param_type) {
+	case TEEC_MEMREF_TEMP_INPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		shm->flags = TEEC_MEM_INPUT;
+		break;
+	case TEEC_MEMREF_TEMP_OUTPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		shm->flags = TEEC_MEM_OUTPUT;
+		break;
+	case TEEC_MEMREF_TEMP_INOUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		shm->flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+	shm->size = tmpref->size;
+
+	if (!tmpref->buffer) {
+		if (tmpref->size)
+			return TEEC_ERROR_BAD_PARAMETERS;
+
+		if (ctx->imp.memref_null) {
+			/* Null pointer, indicate no shared memory attached */
+			MEMREF_SHM_ID(param) = TEE_MEMREF_NULL;
+			shm->imp.id = -1;
+		} else {
+			res = TEEC_AllocateSharedMemory(ctx, shm);
+			if (res != TEEC_SUCCESS)
+				return res;
+			MEMREF_SHM_ID(param) = shm->imp.id;
+		}
+	} else {
+		shm->buffer = tmpref->buffer;
+		res = TEEC_RegisterSharedMemory(ctx, shm);
+		if (res != TEEC_SUCCESS)
+			return res;
+
+		if (shm->imp.shadow_buffer)
+			memcpy(shm->imp.shadow_buffer, tmpref->buffer,
+			       tmpref->size);
+
+		MEMREF_SHM_ID(param) = shm->imp.id;
+	}
+
+	MEMREF_SIZE(param) = tmpref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_whole(
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	const uint32_t inout = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+	uint32_t flags = memref->parent->flags & inout;
+	TEEC_SharedMemory *shm = NULL;
+
+	if (flags == inout)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+	else if (flags & TEEC_MEM_INPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	else if (flags & TEEC_MEM_OUTPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+	else
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	shm = memref->parent;
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && (flags & TEEC_MEM_INPUT))
+		memcpy(shm->imp.shadow_buffer, shm->buffer, shm->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SIZE(param) = shm->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	uint32_t req_shm_flags = 0;
+	TEEC_SharedMemory *shm = NULL;
+
+	switch (param_type) {
+	case TEEC_MEMREF_PARTIAL_INPUT:
+		req_shm_flags = TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_OUTPUT:
+		req_shm_flags = TEEC_MEM_OUTPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_INOUT:
+		req_shm_flags = TEEC_MEM_OUTPUT | TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	shm = memref->parent;
+
+	if ((shm->flags & req_shm_flags) != req_shm_flags)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if ((memref->offset + memref->size < memref->offset) ||
+	    (memref->offset + memref->size > shm->size))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && param_type != TEEC_MEMREF_PARTIAL_OUTPUT)
+		memcpy((char *)shm->imp.shadow_buffer + memref->offset,
+		       (char *)shm->buffer + memref->offset, memref->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SHM_OFFS(param) = memref->offset;
+	MEMREF_SIZE(param) = memref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
+			TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	memset(shms, 0, sizeof(TEEC_SharedMemory) *
+			TEEC_CONFIG_PAYLOAD_REF_COUNT);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++)
+		shms[n].imp.id = -1;
+
+	if (!operation) {
+		memset(params, 0, sizeof(struct tee_ioctl_param) *
+				  TEEC_CONFIG_PAYLOAD_REF_COUNT);
+		return TEEC_SUCCESS;
+	}
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		// mutex = &teec_mutex;
+		return TEEC_ERROR_BUSY;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing an operation more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the operation object to be initialized with 0
+	*/
+	// if (operation->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_NONE:
+			params[n].attr = param_type;
+			break;
+		case TEEC_VALUE_INPUT:
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			params[n].attr = param_type;
+			params[n].a = operation->params[n].value.a;
+			params[n].b = operation->params[n].value.b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			res = teec_pre_process_tmpref(ctx, param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_WHOLE:
+			res = teec_pre_process_whole(
+					&operation->params[n].memref,
+					params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			res = teec_pre_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		default:
+			res = TEEC_ERROR_BAD_PARAMETERS;
+			goto out;
+		}
+	}
+	operation->imp.is_initialized = true;
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = TEEC_Mutex_Pool_V2_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+	return res;
+}
+
+static void teec_post_process_tmpref(uint32_t param_type,
+			TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	if (param_type != TEEC_MEMREF_TEMP_INPUT) {
+		if (tmpref->buffer && shm->imp.shadow_buffer)
+			memcpy(tmpref->buffer, shm->imp.shadow_buffer,
+			       MIN(MEMREF_SIZE(param), tmpref->size));
+
+		tmpref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_whole(TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	TEEC_SharedMemory *shm = memref->parent;
+
+	if (shm->flags & TEEC_MEM_OUTPUT) {
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= shm->size)
+			memcpy(shm->buffer, shm->imp.shadow_buffer,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	if (param_type != TEEC_MEMREF_PARTIAL_INPUT) {
+		TEEC_SharedMemory *shm = memref->parent;
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= memref->size)
+			memcpy((char *)shm->buffer + memref->offset,
+			       (char *)shm->imp.shadow_buffer + memref->offset,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_operation(TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (!operation->imp.is_initialized) {
+		goto out;
+	}
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_VALUE_INPUT:
+			break;
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			operation->params[n].value.a = params[n].a;
+			operation->params[n].value.b = params[n].b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			teec_post_process_tmpref(param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			break;
+		case TEEC_MEMREF_WHOLE:
+			teec_post_process_whole(&operation->params[n].memref,
+						params + n);
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			teec_post_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+		default:
+			break;
+		}
+	}
+
+	// MOD: release mutex
+out:
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = TEEC_Mutex_Pool_V2_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+}
+
+static void teec_free_temp_refs(TEEC_Operation *operation,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		switch (TEEC_PARAM_TYPE_GET(operation->paramTypes, n)) {
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			TEEC_ReleaseSharedMemory(shms + n);
+			break;
+		default:
+			break;
+		}
+	}
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = TEEC_Mutex_Pool_V2_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+}
+
+static TEEC_Result ioctl_errno_to_res(int err)
+{
+	switch (err) {
+	case ENOMEM:
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	case EINVAL:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	default:
+		return TEEC_ERROR_GENERIC;
+	}
+}
+
+static void uuid_to_octets(uint8_t d[TEE_IOCTL_UUID_LEN], const TEEC_UUID *s)
+{
+	d[0] = s->timeLow >> 24;
+	d[1] = s->timeLow >> 16;
+	d[2] = s->timeLow >> 8;
+	d[3] = s->timeLow;
+	d[4] = s->timeMid >> 8;
+	d[5] = s->timeMid;
+	d[6] = s->timeHiAndVersion >> 8;
+	d[7] = s->timeHiAndVersion;
+	memcpy(d + 8, s->clockSeqAndNode, sizeof(s->clockSeqAndNode));
+}
+
+static void setup_client_data(struct tee_ioctl_open_session_arg *arg,
+			      uint32_t connection_method,
+			      const void *connection_data)
+{
+	arg->clnt_login = connection_method;
+
+	switch (connection_method) {
+	case TEE_IOCTL_LOGIN_PUBLIC:
+		/* No connection data to pass */
+		break;
+	case TEE_IOCTL_LOGIN_USER:
+		/* Kernel auto-fills UID and forms client UUID */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP:
+		/*
+		 * Connection data for group login is uint32_t and rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	case TEE_IOCTL_LOGIN_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier and forms client
+		 * UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_USER_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier, UID and forms
+		 * client UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP_APPLICATION:
+		/*
+		 * Connection data for group login is uint32_t rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership, auto-fills application
+		 * identifier and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	default:
+		/*
+		 * Unknown login method, don't pass any connection data as we
+		 * don't know size.
+		 */
+		break;
+	}
+}
+
+TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,
+			const TEEC_UUID *destination,
+			uint32_t connection_method, const void *connection_data,
+			TEEC_Operation *operation, uint32_t *ret_origin)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_open_session_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_open_session_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_open_session_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&shm, 0, sizeof(shm));
+	memset(&buf_data, 0, sizeof(buf_data));
+
+	if (!ctx || !session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	key = ADDR_TO_KEY(session);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		// mutex = &teec_mutex;
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BUSY;
+		goto out;
+	}
+
+	// MOD: avoid initializing a session more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the session object to be initialized with 0
+	*/
+	// teec_mutex_lock(mutex);
+	// if (session->imp.is_initialized) {
+	// 	teec_mutex_unlock(mutex);
+	// 	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+	// 	eorig = TEEC_ORIGIN_API;
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+	// teec_mutex_unlock(mutex);
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	uuid_to_octets(arg->uuid, destination);
+
+	setup_client_data(arg, connection_method, connection_data);
+
+	res = teec_pre_process_operation(ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(ctx->imp.fd, TEE_IOC_OPEN_SESSION, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_OPEN_SESSION failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	if (res == TEEC_SUCCESS) {
+		// MOD: add mutex for multi-thread CA call on the same session
+		teec_mutex_lock(mutex);
+		session->imp.ctx = ctx;
+		session->imp.session_id = arg->session;
+		session->imp.is_initialized = true;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+	}
+	teec_post_process_operation(operation, params, shm);
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+out:
+	if (ret_origin)
+		*ret_origin = eorig;
+	return res;
+}
+
+void TEEC_CloseSession(TEEC_Session *session)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_close_session_arg arg;
+	int rc = 0;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!session)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	key = ADDR_TO_KEY(session);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid close an uninitialized session
+	if (session->imp.is_initialized) {
+		arg.session = session->imp.session_id;
+		rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_CLOSE_SESSION, &arg);
+		if (!rc) {
+			session->imp.is_initialized = false;
+		}
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+
+	if (rc)
+		EMSG("Failed to close session 0x%x", session->imp.session_id);
+}
+
+TEEC_Result TEEC_InvokeCommand(TEEC_Session *session, uint32_t cmd_id,
+			TEEC_Operation *operation, uint32_t *error_origin)
+{
+	struct tee_ioctl_invoke_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_invoke_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_invoke_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&buf_data, 0, sizeof(buf_data));
+	memset(&shm, 0, sizeof(shm));
+
+	if (!session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	arg->session = session->imp.session_id;
+	arg->func = cmd_id;
+
+	if (operation) {
+		teec_mutex_lock(&teec_mutex);
+		operation->imp.session = session;
+		teec_mutex_unlock(&teec_mutex);
+	}
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = TEEC_Mutex_Pool_V2_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+	res = teec_pre_process_operation(session->imp.ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_INVOKE, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_INVOKE failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	teec_post_process_operation(operation, params, shm);
+
+	// MOD: temporary statistic code
+	mutex_mem = TEEC_Mutex_Pool_V2_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+out:
+	if (error_origin)
+		*error_origin = eorig;
+	return res;
+}
+
+void TEEC_RequestCancellation(TEEC_Operation *operation)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Session *session = NULL;
+	struct tee_ioctl_cancel_arg arg;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!operation)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same operation
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+
+	teec_mutex_lock(mutex);
+	session = operation->imp.session;
+	operation->imp.is_initialized = false;
+	teec_mutex_unlock(mutex);
+
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+
+	if (!session)
+		return;
+
+	arg.session = session->imp.session_id;
+	arg.cancel_id = 0;
+
+	if (ioctl(session->imp.ctx->imp.fd, TEE_IOC_CANCEL, &arg))
+		EMSG("TEE_IOC_CANCEL: %s", strerror(errno));
+}
+
+TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	int fd = 0;
+	size_t s = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->buffer)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		// mutex = &teec_shm_mutex;
+		return TEEC_ERROR_BUSY;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.shadow_buffer = NULL;
+			shm->imp.flags = 0;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		/*
+		 * If we're here TEE_IOC_SHM_REGISTER failed, probably
+		 * because some read-only memory was supplied and the Linux
+		 * kernel doesn't like that at the moment.
+		 *
+		 * The error could also have some other origin. In any case
+		 * we're not making matters worse by trying to allocate and
+		 * register a shadow buffer before giving up.
+		 */
+		shm->imp.shadow_buffer = teec_paged_aligned_alloc(s);
+		if (!shm->imp.shadow_buffer) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		fd = teec_shm_register(ctx->imp.fd, shm->imp.shadow_buffer, s,
+				       &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.flags = SHM_FLAG_SHADOW_BUFFER_ALLOCED;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		if (errno == ENOMEM)
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+		else
+			res = TEEC_ERROR_GENERIC;
+		free(shm->imp.shadow_buffer);
+		shm->imp.shadow_buffer = NULL;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+		TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+		return res;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+
+		shm->imp.shadow_buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+					  MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->imp.shadow_buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		shm->imp.registered_fd = -1;
+		shm->imp.flags = 0;
+		shm->imp.is_initialized = true;
+	}
+
+out:
+	shm->imp.alloced_size = s;
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,
+						    TEEC_SharedMemory *shm,
+						    int fd)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	int rfd = 0;
+	struct tee_ioctl_shm_register_fd_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	if (!ctx || !shm || fd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	data.fd = fd;
+	rfd = ioctl(ctx->imp.fd, TEE_IOC_SHM_REGISTER_FD, &data);
+	if (rfd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		// mutex = &teec_shm_mutex;
+		return TEEC_ERROR_BUSY;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	shm->buffer = NULL;
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.registered_fd = rfd;
+	shm->imp.id = data.id;
+	shm->size = data.size;
+	shm->imp.is_initialized = true;
+	goto out;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	int fd = 0;
+	size_t s = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Result res = TEEC_SUCCESS;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		// mutex = &teec_shm_mutex;
+		return TEEC_ERROR_BUSY;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		shm->buffer = teec_paged_aligned_alloc(s);
+		if (!shm->buffer) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd < 0) {
+			free(shm->buffer);
+			shm->buffer = NULL;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = fd;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		shm->buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+				   MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = -1;
+	}
+
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.alloced_size = s;
+	shm->imp.flags = SHM_FLAG_BUFFER_ALLOCED;
+	shm->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+
+	return res;
+}
+
+void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!shm)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_V2_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (shm->imp.id == -1 || !shm->imp.is_initialized) {
+		goto out;
+	}
+
+	if (shm->imp.shadow_buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags &
+			    SHM_FLAG_SHADOW_BUFFER_ALLOCED)
+				free(shm->imp.shadow_buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->imp.shadow_buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags & SHM_FLAG_BUFFER_ALLOCED)
+				free(shm->buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->imp.registered_fd >= 0) {
+		close(shm->imp.registered_fd);
+	}
+
+	shm->imp.id = -1;
+	shm->imp.shadow_buffer = NULL;
+	shm->buffer = NULL;
+	shm->imp.registered_fd = -1;
+	shm->imp.flags = 0;
+	shm->imp.is_initialized = false;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_V2_Unset(&teec_mutex_pool, key);
+}
diff --git a/libteec/src/tee_client_api_per_type.c b/libteec/src/tee_client_api_per_type.c
new file mode 100644
index 0000000..fbc0b0c
--- /dev/null
+++ b/libteec/src/tee_client_api_per_type.c
@@ -0,0 +1,1167 @@
+/*
+ * Copyright (c) 2015-2016, Linaro Limited
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <tee_client_api_extensions.h>
+#include <tee_client_api.h>
+#include <teec_mutex_pool.h>
+#include <teec_trace.h>
+#include <unistd.h>
+
+#ifndef __aligned
+#define __aligned(x) __attribute__((__aligned__(x)))
+#endif
+#include <linux/tee.h>
+
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
+/* How many device sequence numbers will be tried before giving up */
+#define TEEC_MAX_DEV_SEQ	10
+
+/* Helpers to access memref parts of a struct tee_ioctl_param */
+#define MEMREF_SHM_ID(p)	((p)->c)
+#define MEMREF_SHM_OFFS(p)	((p)->a)
+#define MEMREF_SIZE(p)		((p)->b)
+
+/*
+ * Internal flags of TEEC_SharedMemory::internal.flags
+ */
+#define SHM_FLAG_BUFFER_ALLOCED		(1u << 0)
+#define SHM_FLAG_SHADOW_BUFFER_ALLOCED	(1u << 1)
+
+// MOD: mutex for shared memory
+static pthread_mutex_t teec_shm_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex for context
+static pthread_mutex_t teec_ctx_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex for session
+static pthread_mutex_t teec_sess_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex for operation
+static pthread_mutex_t teec_ops_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static void teec_mutex_lock(pthread_mutex_t *mu)
+{
+	pthread_mutex_lock(mu);
+}
+
+static void teec_mutex_unlock(pthread_mutex_t *mu)
+{
+	pthread_mutex_unlock(mu);
+}
+
+static void *teec_paged_aligned_alloc(size_t sz)
+{
+	void *p = NULL;
+	size_t page_sz = sysconf(_SC_PAGESIZE);
+	size_t aligned_sz = ((sz + page_sz - 1) / page_sz) * page_sz;
+
+	if (aligned_sz >= sz && !posix_memalign(&p, page_sz, aligned_sz))
+		return p;
+
+	return NULL;
+}
+
+static int teec_open_dev(const char *devname, const char *capabilities,
+			 uint32_t *gen_caps)
+{
+	int fd = 0;
+	struct tee_ioctl_version_data vers;
+
+	memset(&vers, 0, sizeof(vers));
+
+	fd = open(devname, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	if (ioctl(fd, TEE_IOC_VERSION, &vers)) {
+		EMSG("TEE_IOC_VERSION failed");
+		goto err;
+	}
+
+	/* We can only handle GP TEEs */
+	if (!(vers.gen_caps & TEE_GEN_CAP_GP))
+		goto err;
+
+	if (capabilities) {
+		if (strcmp(capabilities, "optee-tz") == 0) {
+			if (vers.impl_id != TEE_IMPL_ID_OPTEE)
+				goto err;
+			if (!(vers.impl_caps & TEE_OPTEE_CAP_TZ))
+				goto err;
+		} else {
+			/* Unrecognized capability requested */
+			goto err;
+		}
+	}
+
+	*gen_caps = vers.gen_caps;
+	return fd;
+err:
+	close(fd);
+	return -1;
+}
+
+static int teec_shm_alloc(int fd, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_alloc_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.size = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_ALLOC, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+static int teec_shm_register(int fd, void *buf, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_register_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.addr = (uintptr_t)buf;
+	data.length = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_REGISTER, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)
+{
+	char devname[PATH_MAX] = { 0 };
+	int fd = 0;
+	size_t n = 0;
+
+	if (!ctx)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: avoid initializing an ctx more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the ctx object to be initialized with 0
+	*/
+	// teec_mutex_lock(&teec_ctx_mutex);
+	// if (ctx->imp.is_initialized) {
+	// 	teec_mutex_unlock(&teec_ctx_mutex);
+	// 	return TEEC_ERROR_BAD_PARAMETERS;
+	// }
+	// teec_mutex_unlock(&teec_ctx_mutex);
+
+	for (n = 0; n < TEEC_MAX_DEV_SEQ; n++) {
+		uint32_t gen_caps = 0;
+
+		snprintf(devname, sizeof(devname), "/dev/tee%zu", n);
+		fd = teec_open_dev(devname, name, &gen_caps);
+		if (fd >= 0) {
+			// MOD: add mutex for multi-thread CA call on the same ctx
+			teec_mutex_lock(&teec_ctx_mutex);
+			ctx->imp.fd = fd;
+			ctx->imp.reg_mem = gen_caps & TEE_GEN_CAP_REG_MEM;
+			ctx->imp.memref_null = gen_caps & TEE_GEN_CAP_MEMREF_NULL;
+			ctx->imp.is_initialized = true;
+			// MOD: release mutex
+			teec_mutex_unlock(&teec_ctx_mutex);
+			return TEEC_SUCCESS;
+		}
+	}
+
+	return TEEC_ERROR_ITEM_NOT_FOUND;
+}
+
+void TEEC_FinalizeContext(TEEC_Context *ctx)
+{
+	if (ctx) {
+		// MOD: add mutex for multi-thread CA call on the same ctx
+		teec_mutex_lock(&teec_ctx_mutex);
+		// MOD: avoid finalizing an uninitialized ctx
+		if (ctx->imp.is_initialized) {
+			close(ctx->imp.fd);
+			ctx->imp.is_initialized = false;
+		}
+		// MOD: release mutex
+		teec_mutex_unlock(&teec_ctx_mutex);
+	}
+}
+
+
+static TEEC_Result teec_pre_process_tmpref(TEEC_Context *ctx,
+			uint32_t param_type, TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+
+	switch (param_type) {
+	case TEEC_MEMREF_TEMP_INPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		shm->flags = TEEC_MEM_INPUT;
+		break;
+	case TEEC_MEMREF_TEMP_OUTPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		shm->flags = TEEC_MEM_OUTPUT;
+		break;
+	case TEEC_MEMREF_TEMP_INOUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		shm->flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+	shm->size = tmpref->size;
+
+	if (!tmpref->buffer) {
+		if (tmpref->size)
+			return TEEC_ERROR_BAD_PARAMETERS;
+
+		if (ctx->imp.memref_null) {
+			/* Null pointer, indicate no shared memory attached */
+			MEMREF_SHM_ID(param) = TEE_MEMREF_NULL;
+			shm->imp.id = -1;
+		} else {
+			res = TEEC_AllocateSharedMemory(ctx, shm);
+			if (res != TEEC_SUCCESS)
+				return res;
+			MEMREF_SHM_ID(param) = shm->imp.id;
+		}
+	} else {
+		shm->buffer = tmpref->buffer;
+		res = TEEC_RegisterSharedMemory(ctx, shm);
+		if (res != TEEC_SUCCESS)
+			return res;
+
+		if (shm->imp.shadow_buffer)
+			memcpy(shm->imp.shadow_buffer, tmpref->buffer,
+			       tmpref->size);
+
+		MEMREF_SHM_ID(param) = shm->imp.id;
+	}
+
+	MEMREF_SIZE(param) = tmpref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_whole(
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	const uint32_t inout = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+	uint32_t flags = memref->parent->flags & inout;
+	TEEC_SharedMemory *shm = NULL;
+
+	if (flags == inout)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+	else if (flags & TEEC_MEM_INPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	else if (flags & TEEC_MEM_OUTPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+	else
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	shm = memref->parent;
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && (flags & TEEC_MEM_INPUT))
+		memcpy(shm->imp.shadow_buffer, shm->buffer, shm->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SIZE(param) = shm->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	uint32_t req_shm_flags = 0;
+	TEEC_SharedMemory *shm = NULL;
+
+	switch (param_type) {
+	case TEEC_MEMREF_PARTIAL_INPUT:
+		req_shm_flags = TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_OUTPUT:
+		req_shm_flags = TEEC_MEM_OUTPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_INOUT:
+		req_shm_flags = TEEC_MEM_OUTPUT | TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	shm = memref->parent;
+
+	if ((shm->flags & req_shm_flags) != req_shm_flags)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if ((memref->offset + memref->size < memref->offset) ||
+	    (memref->offset + memref->size > shm->size))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && param_type != TEEC_MEMREF_PARTIAL_OUTPUT)
+		memcpy((char *)shm->imp.shadow_buffer + memref->offset,
+		       (char *)shm->buffer + memref->offset, memref->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SHM_OFFS(param) = memref->offset;
+	MEMREF_SIZE(param) = memref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
+			TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	size_t n = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	memset(shms, 0, sizeof(TEEC_SharedMemory) *
+			TEEC_CONFIG_PAYLOAD_REF_COUNT);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++)
+		shms[n].imp.id = -1;
+
+	if (!operation) {
+		memset(params, 0, sizeof(struct tee_ioctl_param) *
+				  TEEC_CONFIG_PAYLOAD_REF_COUNT);
+		return TEEC_SUCCESS;
+	}
+
+	mutex = &teec_ops_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing an operation more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the operation object to be initialized with 0
+	*/
+	// if (operation->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_NONE:
+			params[n].attr = param_type;
+			break;
+		case TEEC_VALUE_INPUT:
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			params[n].attr = param_type;
+			params[n].a = operation->params[n].value.a;
+			params[n].b = operation->params[n].value.b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			res = teec_pre_process_tmpref(ctx, param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_WHOLE:
+			res = teec_pre_process_whole(
+					&operation->params[n].memref,
+					params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			res = teec_pre_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		default:
+			res = TEEC_ERROR_BAD_PARAMETERS;
+			goto out;
+		}
+	}
+	operation->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	return res;
+}
+
+static void teec_post_process_tmpref(uint32_t param_type,
+			TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	if (param_type != TEEC_MEMREF_TEMP_INPUT) {
+		if (tmpref->buffer && shm->imp.shadow_buffer)
+			memcpy(tmpref->buffer, shm->imp.shadow_buffer,
+			       MIN(MEMREF_SIZE(param), tmpref->size));
+
+		tmpref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_whole(TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	TEEC_SharedMemory *shm = memref->parent;
+
+	if (shm->flags & TEEC_MEM_OUTPUT) {
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= shm->size)
+			memcpy(shm->buffer, shm->imp.shadow_buffer,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	if (param_type != TEEC_MEMREF_PARTIAL_INPUT) {
+		TEEC_SharedMemory *shm = memref->parent;
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= memref->size)
+			memcpy((char *)shm->buffer + memref->offset,
+			       (char *)shm->imp.shadow_buffer + memref->offset,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_operation(TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	mutex = &teec_ops_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (!operation->imp.is_initialized) {
+		goto out;
+	}
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_VALUE_INPUT:
+			break;
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			operation->params[n].value.a = params[n].a;
+			operation->params[n].value.b = params[n].b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			teec_post_process_tmpref(param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			break;
+		case TEEC_MEMREF_WHOLE:
+			teec_post_process_whole(&operation->params[n].memref,
+						params + n);
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			teec_post_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+		default:
+			break;
+		}
+	}
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+}
+
+static void teec_free_temp_refs(TEEC_Operation *operation,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	mutex = &teec_ops_mutex;
+	teec_mutex_lock(mutex);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		switch (TEEC_PARAM_TYPE_GET(operation->paramTypes, n)) {
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			TEEC_ReleaseSharedMemory(shms + n);
+			break;
+		default:
+			break;
+		}
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+}
+
+static TEEC_Result ioctl_errno_to_res(int err)
+{
+	switch (err) {
+	case ENOMEM:
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	case EINVAL:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	default:
+		return TEEC_ERROR_GENERIC;
+	}
+}
+
+static void uuid_to_octets(uint8_t d[TEE_IOCTL_UUID_LEN], const TEEC_UUID *s)
+{
+	d[0] = s->timeLow >> 24;
+	d[1] = s->timeLow >> 16;
+	d[2] = s->timeLow >> 8;
+	d[3] = s->timeLow;
+	d[4] = s->timeMid >> 8;
+	d[5] = s->timeMid;
+	d[6] = s->timeHiAndVersion >> 8;
+	d[7] = s->timeHiAndVersion;
+	memcpy(d + 8, s->clockSeqAndNode, sizeof(s->clockSeqAndNode));
+}
+
+static void setup_client_data(struct tee_ioctl_open_session_arg *arg,
+			      uint32_t connection_method,
+			      const void *connection_data)
+{
+	arg->clnt_login = connection_method;
+
+	switch (connection_method) {
+	case TEE_IOCTL_LOGIN_PUBLIC:
+		/* No connection data to pass */
+		break;
+	case TEE_IOCTL_LOGIN_USER:
+		/* Kernel auto-fills UID and forms client UUID */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP:
+		/*
+		 * Connection data for group login is uint32_t and rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	case TEE_IOCTL_LOGIN_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier and forms client
+		 * UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_USER_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier, UID and forms
+		 * client UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP_APPLICATION:
+		/*
+		 * Connection data for group login is uint32_t rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership, auto-fills application
+		 * identifier and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	default:
+		/*
+		 * Unknown login method, don't pass any connection data as we
+		 * don't know size.
+		 */
+		break;
+	}
+}
+
+TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,
+			const TEEC_UUID *destination,
+			uint32_t connection_method, const void *connection_data,
+			TEEC_Operation *operation, uint32_t *ret_origin)
+{
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_open_session_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_open_session_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_open_session_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&shm, 0, sizeof(shm));
+	memset(&buf_data, 0, sizeof(buf_data));
+
+	if (!ctx || !session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	mutex = &teec_sess_mutex;
+
+	// MOD: avoid initializing a session more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the session object to be initialized with 0
+	*/
+	// teec_mutex_lock(mutex);
+	// if (session->imp.is_initialized) {
+	// 	teec_mutex_unlock(mutex);
+	// 	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	// 	eorig = TEEC_ORIGIN_API;
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+	// teec_mutex_unlock(mutex);
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	uuid_to_octets(arg->uuid, destination);
+
+	setup_client_data(arg, connection_method, connection_data);
+
+	res = teec_pre_process_operation(ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(ctx->imp.fd, TEE_IOC_OPEN_SESSION, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_OPEN_SESSION failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	if (res == TEEC_SUCCESS) {
+		// MOD: add mutex for multi-thread CA call on the same session
+		teec_mutex_lock(mutex);
+		session->imp.ctx = ctx;
+		session->imp.session_id = arg->session;
+		session->imp.is_initialized = true;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+	}
+	teec_post_process_operation(operation, params, shm);
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+out:
+	if (ret_origin)
+		*ret_origin = eorig;
+	return res;
+}
+
+void TEEC_CloseSession(TEEC_Session *session)
+{
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_close_session_arg arg;
+	int rc = 0;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!session)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	mutex = &teec_sess_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid close an uninitialized session
+	if (session->imp.is_initialized) {
+		arg.session = session->imp.session_id;
+		rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_CLOSE_SESSION, &arg);
+		if (!rc) {
+			session->imp.is_initialized = false;
+		}
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+
+	if (rc)
+		EMSG("Failed to close session 0x%x", session->imp.session_id);
+}
+
+TEEC_Result TEEC_InvokeCommand(TEEC_Session *session, uint32_t cmd_id,
+			TEEC_Operation *operation, uint32_t *error_origin)
+{
+	struct tee_ioctl_invoke_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_invoke_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_invoke_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&buf_data, 0, sizeof(buf_data));
+	memset(&shm, 0, sizeof(shm));
+
+	if (!session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	arg->session = session->imp.session_id;
+	arg->func = cmd_id;
+
+	if (operation) {
+		teec_mutex_lock(&teec_ops_mutex);
+		operation->imp.session = session;
+		teec_mutex_unlock(&teec_ops_mutex);
+	}
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = sizeof(teec_shm_mutex) + sizeof(teec_ctx_mutex) + sizeof(teec_sess_mutex) + sizeof(teec_ops_mutex);
+	operation->params[3].value.a = mutex_mem;
+
+	res = teec_pre_process_operation(session->imp.ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_INVOKE, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_INVOKE failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	teec_post_process_operation(operation, params, shm);
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+out:
+	if (error_origin)
+		*error_origin = eorig;
+	return res;
+}
+
+void TEEC_RequestCancellation(TEEC_Operation *operation)
+{
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Session *session = NULL;
+	struct tee_ioctl_cancel_arg arg;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!operation)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same operation
+	mutex = &teec_ops_mutex;
+
+	teec_mutex_lock(mutex);
+	session = operation->imp.session;
+	operation->imp.is_initialized = false;
+	teec_mutex_unlock(mutex);
+
+	if (!session)
+		return;
+
+	arg.session = session->imp.session_id;
+	arg.cancel_id = 0;
+
+	if (ioctl(session->imp.ctx->imp.fd, TEE_IOC_CANCEL, &arg))
+		EMSG("TEE_IOC_CANCEL: %s", strerror(errno));
+}
+
+TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	int fd = 0;
+	size_t s = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->buffer)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	mutex = &teec_shm_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.shadow_buffer = NULL;
+			shm->imp.flags = 0;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		/*
+		 * If we're here TEE_IOC_SHM_REGISTER failed, probably
+		 * because some read-only memory was supplied and the Linux
+		 * kernel doesn't like that at the moment.
+		 *
+		 * The error could also have some other origin. In any case
+		 * we're not making matters worse by trying to allocate and
+		 * register a shadow buffer before giving up.
+		 */
+		shm->imp.shadow_buffer = teec_paged_aligned_alloc(s);
+		if (!shm->imp.shadow_buffer) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		fd = teec_shm_register(ctx->imp.fd, shm->imp.shadow_buffer, s,
+				       &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.flags = SHM_FLAG_SHADOW_BUFFER_ALLOCED;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		if (errno == ENOMEM)
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+		else
+			res = TEEC_ERROR_GENERIC;
+		free(shm->imp.shadow_buffer);
+		shm->imp.shadow_buffer = NULL;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+		return res;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+
+		shm->imp.shadow_buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+					  MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->imp.shadow_buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		shm->imp.registered_fd = -1;
+		shm->imp.flags = 0;
+		shm->imp.is_initialized = true;
+	}
+
+out:
+	shm->imp.alloced_size = s;
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,
+						    TEEC_SharedMemory *shm,
+						    int fd)
+{
+	pthread_mutex_t *mutex = NULL;
+	int rfd = 0;
+	struct tee_ioctl_shm_register_fd_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	if (!ctx || !shm || fd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	data.fd = fd;
+	rfd = ioctl(ctx->imp.fd, TEE_IOC_SHM_REGISTER_FD, &data);
+	if (rfd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	mutex = &teec_shm_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	shm->buffer = NULL;
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.registered_fd = rfd;
+	shm->imp.id = data.id;
+	shm->size = data.size;
+	shm->imp.is_initialized = true;
+	goto out;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	int fd = 0;
+	size_t s = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Result res = TEEC_SUCCESS;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	mutex = &teec_shm_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		shm->buffer = teec_paged_aligned_alloc(s);
+		if (!shm->buffer) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd < 0) {
+			free(shm->buffer);
+			shm->buffer = NULL;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = fd;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		shm->buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+				   MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = -1;
+	}
+
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.alloced_size = s;
+	shm->imp.flags = SHM_FLAG_BUFFER_ALLOCED;
+	shm->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+
+	return res;
+}
+
+void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
+{
+	pthread_mutex_t *mutex = NULL;
+
+	if (!shm)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	mutex = &teec_shm_mutex;
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (shm->imp.id == -1 || !shm->imp.is_initialized) {
+		goto out;
+	}
+
+	if (shm->imp.shadow_buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags &
+			    SHM_FLAG_SHADOW_BUFFER_ALLOCED)
+				free(shm->imp.shadow_buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->imp.shadow_buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags & SHM_FLAG_BUFFER_ALLOCED)
+				free(shm->buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->imp.registered_fd >= 0) {
+		close(shm->imp.registered_fd);
+	}
+
+	shm->imp.id = -1;
+	shm->imp.shadow_buffer = NULL;
+	shm->buffer = NULL;
+	shm->imp.registered_fd = -1;
+	shm->imp.flags = 0;
+	shm->imp.is_initialized = false;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+}
diff --git a/libteec/src/tee_client_api_pool.c b/libteec/src/tee_client_api_pool.c
new file mode 100644
index 0000000..97acb26
--- /dev/null
+++ b/libteec/src/tee_client_api_pool.c
@@ -0,0 +1,1256 @@
+/*
+ * Copyright (c) 2015-2016, Linaro Limited
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <tee_client_api_extensions.h>
+#include <tee_client_api.h>
+#include <teec_mutex_pool.h>
+#include <teec_trace.h>
+#include <unistd.h>
+
+#ifndef __aligned
+#define __aligned(x) __attribute__((__aligned__(x)))
+#endif
+#include <linux/tee.h>
+
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
+/* How many device sequence numbers will be tried before giving up */
+#define TEEC_MAX_DEV_SEQ	10
+
+/* Helpers to access memref parts of a struct tee_ioctl_param */
+#define MEMREF_SHM_ID(p)	((p)->c)
+#define MEMREF_SHM_OFFS(p)	((p)->a)
+#define MEMREF_SIZE(p)		((p)->b)
+
+/*
+ * Internal flags of TEEC_SharedMemory::internal.flags
+ */
+#define SHM_FLAG_BUFFER_ALLOCED		(1u << 0)
+#define SHM_FLAG_SHADOW_BUFFER_ALLOCED	(1u << 1)
+
+static pthread_mutex_t teec_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex for shared memory
+static pthread_mutex_t teec_shm_mutex = PTHREAD_MUTEX_INITIALIZER;
+// MOD: mutex pool
+static TEEC_Mutex_Pool teec_mutex_pool = { .key = {0}, .val = {PTHREAD_MUTEX_INITIALIZER} };
+
+static void teec_mutex_lock(pthread_mutex_t *mu)
+{
+	pthread_mutex_lock(mu);
+}
+
+static void teec_mutex_unlock(pthread_mutex_t *mu)
+{
+	pthread_mutex_unlock(mu);
+}
+
+static void *teec_paged_aligned_alloc(size_t sz)
+{
+	void *p = NULL;
+	size_t page_sz = sysconf(_SC_PAGESIZE);
+	size_t aligned_sz = ((sz + page_sz - 1) / page_sz) * page_sz;
+
+	if (aligned_sz >= sz && !posix_memalign(&p, page_sz, aligned_sz))
+		return p;
+
+	return NULL;
+}
+
+static int teec_open_dev(const char *devname, const char *capabilities,
+			 uint32_t *gen_caps)
+{
+	int fd = 0;
+	struct tee_ioctl_version_data vers;
+
+	memset(&vers, 0, sizeof(vers));
+
+	fd = open(devname, O_RDWR);
+	if (fd < 0)
+		return -1;
+
+	if (ioctl(fd, TEE_IOC_VERSION, &vers)) {
+		EMSG("TEE_IOC_VERSION failed");
+		goto err;
+	}
+
+	/* We can only handle GP TEEs */
+	if (!(vers.gen_caps & TEE_GEN_CAP_GP))
+		goto err;
+
+	if (capabilities) {
+		if (strcmp(capabilities, "optee-tz") == 0) {
+			if (vers.impl_id != TEE_IMPL_ID_OPTEE)
+				goto err;
+			if (!(vers.impl_caps & TEE_OPTEE_CAP_TZ))
+				goto err;
+		} else {
+			/* Unrecognized capability requested */
+			goto err;
+		}
+	}
+
+	*gen_caps = vers.gen_caps;
+	return fd;
+err:
+	close(fd);
+	return -1;
+}
+
+static int teec_shm_alloc(int fd, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_alloc_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.size = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_ALLOC, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+static int teec_shm_register(int fd, void *buf, size_t size, int *id)
+{
+	int shm_fd = 0;
+	struct tee_ioctl_shm_register_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	data.addr = (uintptr_t)buf;
+	data.length = size;
+	shm_fd = ioctl(fd, TEE_IOC_SHM_REGISTER, &data);
+	if (shm_fd < 0)
+		return -1;
+	*id = data.id;
+	return shm_fd;
+}
+
+TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx)
+{
+	char devname[PATH_MAX] = { 0 };
+	int fd = 0;
+	size_t n = 0;
+
+	if (!ctx)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: avoid initializing an ctx more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the ctx object to be initialized with 0
+	*/
+	// teec_mutex_lock(&teec_mutex);
+	// if (ctx->imp.is_initialized) {
+	// 	teec_mutex_unlock(&teec_mutex);
+	// 	return TEEC_ERROR_BAD_PARAMETERS;
+	// }
+	// teec_mutex_unlock(&teec_mutex);
+
+	for (n = 0; n < TEEC_MAX_DEV_SEQ; n++) {
+		uint32_t gen_caps = 0;
+
+		snprintf(devname, sizeof(devname), "/dev/tee%zu", n);
+		fd = teec_open_dev(devname, name, &gen_caps);
+		if (fd >= 0) {
+			// MOD: add mutex for multi-thread CA call on the same ctx
+			teec_mutex_lock(&teec_mutex);
+			ctx->imp.fd = fd;
+			ctx->imp.reg_mem = gen_caps & TEE_GEN_CAP_REG_MEM;
+			ctx->imp.memref_null = gen_caps & TEE_GEN_CAP_MEMREF_NULL;
+			ctx->imp.is_initialized = true;
+			// MOD: release mutex
+			teec_mutex_unlock(&teec_mutex);
+			return TEEC_SUCCESS;
+		}
+	}
+
+	return TEEC_ERROR_ITEM_NOT_FOUND;
+}
+
+void TEEC_FinalizeContext(TEEC_Context *ctx)
+{
+	if (ctx) {
+		// MOD: add mutex for multi-thread CA call on the same ctx
+		teec_mutex_lock(&teec_mutex);
+		// MOD: avoid finalizing an uninitialized ctx
+		if (ctx->imp.is_initialized) {
+			close(ctx->imp.fd);
+			ctx->imp.is_initialized = false;
+		}
+		// MOD: release mutex
+		teec_mutex_unlock(&teec_mutex);
+	}
+}
+
+
+static TEEC_Result teec_pre_process_tmpref(TEEC_Context *ctx,
+			uint32_t param_type, TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+
+	switch (param_type) {
+	case TEEC_MEMREF_TEMP_INPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		shm->flags = TEEC_MEM_INPUT;
+		break;
+	case TEEC_MEMREF_TEMP_OUTPUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		shm->flags = TEEC_MEM_OUTPUT;
+		break;
+	case TEEC_MEMREF_TEMP_INOUT:
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		shm->flags = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+	shm->size = tmpref->size;
+
+	if (!tmpref->buffer) {
+		if (tmpref->size)
+			return TEEC_ERROR_BAD_PARAMETERS;
+
+		if (ctx->imp.memref_null) {
+			/* Null pointer, indicate no shared memory attached */
+			MEMREF_SHM_ID(param) = TEE_MEMREF_NULL;
+			shm->imp.id = -1;
+		} else {
+			res = TEEC_AllocateSharedMemory(ctx, shm);
+			if (res != TEEC_SUCCESS)
+				return res;
+			MEMREF_SHM_ID(param) = shm->imp.id;
+		}
+	} else {
+		shm->buffer = tmpref->buffer;
+		res = TEEC_RegisterSharedMemory(ctx, shm);
+		if (res != TEEC_SUCCESS)
+			return res;
+
+		if (shm->imp.shadow_buffer)
+			memcpy(shm->imp.shadow_buffer, tmpref->buffer,
+			       tmpref->size);
+
+		MEMREF_SHM_ID(param) = shm->imp.id;
+	}
+
+	MEMREF_SIZE(param) = tmpref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_whole(
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	const uint32_t inout = TEEC_MEM_INPUT | TEEC_MEM_OUTPUT;
+	uint32_t flags = memref->parent->flags & inout;
+	TEEC_SharedMemory *shm = NULL;
+
+	if (flags == inout)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+	else if (flags & TEEC_MEM_INPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+	else if (flags & TEEC_MEM_OUTPUT)
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+	else
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	shm = memref->parent;
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && (flags & TEEC_MEM_INPUT))
+		memcpy(shm->imp.shadow_buffer, shm->buffer, shm->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SIZE(param) = shm->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	uint32_t req_shm_flags = 0;
+	TEEC_SharedMemory *shm = NULL;
+
+	switch (param_type) {
+	case TEEC_MEMREF_PARTIAL_INPUT:
+		req_shm_flags = TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_OUTPUT:
+		req_shm_flags = TEEC_MEM_OUTPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT;
+		break;
+	case TEEC_MEMREF_PARTIAL_INOUT:
+		req_shm_flags = TEEC_MEM_OUTPUT | TEEC_MEM_INPUT;
+		param->attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT;
+		break;
+	default:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	}
+
+	shm = memref->parent;
+
+	if ((shm->flags & req_shm_flags) != req_shm_flags)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if ((memref->offset + memref->size < memref->offset) ||
+	    (memref->offset + memref->size > shm->size))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	/*
+	 * We're using a shadow buffer in this reference, copy the real buffer
+	 * into the shadow buffer if needed. We'll copy it back once we've
+	 * returned from the call to secure world.
+	 */
+	if (shm->imp.shadow_buffer && param_type != TEEC_MEMREF_PARTIAL_OUTPUT)
+		memcpy((char *)shm->imp.shadow_buffer + memref->offset,
+		       (char *)shm->buffer + memref->offset, memref->size);
+
+	MEMREF_SHM_ID(param) = shm->imp.id;
+	MEMREF_SHM_OFFS(param) = memref->offset;
+	MEMREF_SIZE(param) = memref->size;
+
+	return TEEC_SUCCESS;
+}
+
+static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx,
+			TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	memset(shms, 0, sizeof(TEEC_SharedMemory) *
+			TEEC_CONFIG_PAYLOAD_REF_COUNT);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++)
+		shms[n].imp.id = -1;
+
+	if (!operation) {
+		memset(params, 0, sizeof(struct tee_ioctl_param) *
+				  TEEC_CONFIG_PAYLOAD_REF_COUNT);
+		return TEEC_SUCCESS;
+	}
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing an operation more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the operation object to be initialized with 0
+	*/
+	// if (operation->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_NONE:
+			params[n].attr = param_type;
+			break;
+		case TEEC_VALUE_INPUT:
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			params[n].attr = param_type;
+			params[n].a = operation->params[n].value.a;
+			params[n].b = operation->params[n].value.b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			res = teec_pre_process_tmpref(ctx, param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_WHOLE:
+			res = teec_pre_process_whole(
+					&operation->params[n].memref,
+					params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			res = teec_pre_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+			if (res != TEEC_SUCCESS)
+				goto out;
+			break;
+		default:
+			res = TEEC_ERROR_BAD_PARAMETERS;
+			goto out;
+		}
+	}
+	operation->imp.is_initialized = true;
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = TEEC_Mutex_Pool_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	return res;
+}
+
+static void teec_post_process_tmpref(uint32_t param_type,
+			TEEC_TempMemoryReference *tmpref,
+			struct tee_ioctl_param *param,
+			TEEC_SharedMemory *shm)
+{
+	if (param_type != TEEC_MEMREF_TEMP_INPUT) {
+		if (tmpref->buffer && shm->imp.shadow_buffer)
+			memcpy(tmpref->buffer, shm->imp.shadow_buffer,
+			       MIN(MEMREF_SIZE(param), tmpref->size));
+
+		tmpref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_whole(TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	TEEC_SharedMemory *shm = memref->parent;
+
+	if (shm->flags & TEEC_MEM_OUTPUT) {
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= shm->size)
+			memcpy(shm->buffer, shm->imp.shadow_buffer,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_partial(uint32_t param_type,
+			TEEC_RegisteredMemoryReference *memref,
+			struct tee_ioctl_param *param)
+{
+	if (param_type != TEEC_MEMREF_PARTIAL_INPUT) {
+		TEEC_SharedMemory *shm = memref->parent;
+
+		/*
+		 * We're using a shadow buffer in this reference, copy back
+		 * the shadow buffer into the real buffer now that we've
+		 * returned from secure world.
+		 */
+		if (shm->imp.shadow_buffer && MEMREF_SIZE(param) <= memref->size)
+			memcpy((char *)shm->buffer + memref->offset,
+			       (char *)shm->imp.shadow_buffer + memref->offset,
+			       MEMREF_SIZE(param));
+
+		memref->size = MEMREF_SIZE(param);
+	}
+}
+
+static void teec_post_process_operation(TEEC_Operation *operation,
+			struct tee_ioctl_param *params,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (!operation->imp.is_initialized) {
+		goto out;
+	}
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		uint32_t param_type = 0;
+
+		param_type = TEEC_PARAM_TYPE_GET(operation->paramTypes, n);
+		switch (param_type) {
+		case TEEC_VALUE_INPUT:
+			break;
+		case TEEC_VALUE_OUTPUT:
+		case TEEC_VALUE_INOUT:
+			operation->params[n].value.a = params[n].a;
+			operation->params[n].value.b = params[n].b;
+			break;
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			teec_post_process_tmpref(param_type,
+				&operation->params[n].tmpref, params + n,
+				shms + n);
+			break;
+		case TEEC_MEMREF_WHOLE:
+			teec_post_process_whole(&operation->params[n].memref,
+						params + n);
+			break;
+		case TEEC_MEMREF_PARTIAL_INPUT:
+		case TEEC_MEMREF_PARTIAL_OUTPUT:
+		case TEEC_MEMREF_PARTIAL_INOUT:
+			teec_post_process_partial(param_type,
+				&operation->params[n].memref, params + n);
+		default:
+			break;
+		}
+	}
+
+	// MOD: release mutex
+out:
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = TEEC_Mutex_Pool_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+}
+
+static void teec_free_temp_refs(TEEC_Operation *operation,
+			TEEC_SharedMemory *shms)
+{
+	size_t n = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!operation)
+		return;
+
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	for (n = 0; n < TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) {
+		switch (TEEC_PARAM_TYPE_GET(operation->paramTypes, n)) {
+		case TEEC_MEMREF_TEMP_INPUT:
+		case TEEC_MEMREF_TEMP_OUTPUT:
+		case TEEC_MEMREF_TEMP_INOUT:
+			TEEC_ReleaseSharedMemory(shms + n);
+			break;
+		default:
+			break;
+		}
+	}
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = TEEC_Mutex_Pool_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+}
+
+static TEEC_Result ioctl_errno_to_res(int err)
+{
+	switch (err) {
+	case ENOMEM:
+		return TEEC_ERROR_OUT_OF_MEMORY;
+	case EINVAL:
+		return TEEC_ERROR_BAD_PARAMETERS;
+	default:
+		return TEEC_ERROR_GENERIC;
+	}
+}
+
+static void uuid_to_octets(uint8_t d[TEE_IOCTL_UUID_LEN], const TEEC_UUID *s)
+{
+	d[0] = s->timeLow >> 24;
+	d[1] = s->timeLow >> 16;
+	d[2] = s->timeLow >> 8;
+	d[3] = s->timeLow;
+	d[4] = s->timeMid >> 8;
+	d[5] = s->timeMid;
+	d[6] = s->timeHiAndVersion >> 8;
+	d[7] = s->timeHiAndVersion;
+	memcpy(d + 8, s->clockSeqAndNode, sizeof(s->clockSeqAndNode));
+}
+
+static void setup_client_data(struct tee_ioctl_open_session_arg *arg,
+			      uint32_t connection_method,
+			      const void *connection_data)
+{
+	arg->clnt_login = connection_method;
+
+	switch (connection_method) {
+	case TEE_IOCTL_LOGIN_PUBLIC:
+		/* No connection data to pass */
+		break;
+	case TEE_IOCTL_LOGIN_USER:
+		/* Kernel auto-fills UID and forms client UUID */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP:
+		/*
+		 * Connection data for group login is uint32_t and rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	case TEE_IOCTL_LOGIN_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier and forms client
+		 * UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_USER_APPLICATION:
+		/*
+		 * Kernel auto-fills application identifier, UID and forms
+		 * client UUID.
+		 */
+		break;
+	case TEE_IOCTL_LOGIN_GROUP_APPLICATION:
+		/*
+		 * Connection data for group login is uint32_t rest of
+		 * clnt_uuid is set as zero.
+		 *
+		 * Kernel verifies group membership, auto-fills application
+		 * identifier and then forms client UUID.
+		 */
+		memcpy(arg->clnt_uuid, connection_data, sizeof(gid_t));
+		break;
+	default:
+		/*
+		 * Unknown login method, don't pass any connection data as we
+		 * don't know size.
+		 */
+		break;
+	}
+}
+
+TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session,
+			const TEEC_UUID *destination,
+			uint32_t connection_method, const void *connection_data,
+			TEEC_Operation *operation, uint32_t *ret_origin)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_open_session_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_open_session_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_open_session_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&shm, 0, sizeof(shm));
+	memset(&buf_data, 0, sizeof(buf_data));
+
+	if (!ctx || !session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	key = ADDR_TO_KEY(session);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+
+	// MOD: avoid initializing a session more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the session object to be initialized with 0
+	*/
+	// teec_mutex_lock(mutex);
+	// if (session->imp.is_initialized) {
+	// 	teec_mutex_unlock(mutex);
+	// 	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	// 	eorig = TEEC_ORIGIN_API;
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+	// teec_mutex_unlock(mutex);
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	uuid_to_octets(arg->uuid, destination);
+
+	setup_client_data(arg, connection_method, connection_data);
+
+	res = teec_pre_process_operation(ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(ctx->imp.fd, TEE_IOC_OPEN_SESSION, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_OPEN_SESSION failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	if (res == TEEC_SUCCESS) {
+		// MOD: add mutex for multi-thread CA call on the same session
+		teec_mutex_lock(mutex);
+		session->imp.ctx = ctx;
+		session->imp.session_id = arg->session;
+		session->imp.is_initialized = true;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+	}
+	teec_post_process_operation(operation, params, shm);
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+out:
+	if (ret_origin)
+		*ret_origin = eorig;
+	return res;
+}
+
+void TEEC_CloseSession(TEEC_Session *session)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	struct tee_ioctl_close_session_arg arg;
+	int rc = 0;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!session)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same session
+	key = ADDR_TO_KEY(session);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid close an uninitialized session
+	if (session->imp.is_initialized) {
+		arg.session = session->imp.session_id;
+		rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_CLOSE_SESSION, &arg);
+		if (!rc) {
+			session->imp.is_initialized = false;
+		}
+	}
+
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+
+	if (rc)
+		EMSG("Failed to close session 0x%x", session->imp.session_id);
+}
+
+TEEC_Result TEEC_InvokeCommand(TEEC_Session *session, uint32_t cmd_id,
+			TEEC_Operation *operation, uint32_t *error_origin)
+{
+	struct tee_ioctl_invoke_arg *arg = NULL;
+	struct tee_ioctl_param *params = NULL;
+	TEEC_Result res = TEEC_ERROR_GENERIC;
+	uint32_t eorig = 0;
+	int rc = 0;
+	const size_t arg_size = sizeof(struct tee_ioctl_invoke_arg) +
+				TEEC_CONFIG_PAYLOAD_REF_COUNT *
+					sizeof(struct tee_ioctl_param);
+	union {
+		struct tee_ioctl_invoke_arg arg;
+		uint8_t data[arg_size];
+	} buf;
+	struct tee_ioctl_buf_data buf_data;
+	TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT];
+
+	memset(&buf, 0, sizeof(buf));
+	memset(&buf_data, 0, sizeof(buf_data));
+	memset(&shm, 0, sizeof(shm));
+
+	if (!session) {
+		eorig = TEEC_ORIGIN_API;
+		res = TEEC_ERROR_BAD_PARAMETERS;
+		goto out;
+	}
+
+	buf_data.buf_ptr = (uintptr_t)&buf;
+	buf_data.buf_len = sizeof(buf);
+
+	arg = &buf.arg;
+	arg->num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT;
+	params = (struct tee_ioctl_param *)(arg + 1);
+
+	arg->session = session->imp.session_id;
+	arg->func = cmd_id;
+
+	if (operation) {
+		teec_mutex_lock(&teec_mutex);
+		operation->imp.session = session;
+		teec_mutex_unlock(&teec_mutex);
+	}
+
+	// MOD: temporary statistic code
+	size_t mutex_mem = TEEC_Mutex_Pool_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+	res = teec_pre_process_operation(session->imp.ctx, operation, params, shm);
+	if (res != TEEC_SUCCESS) {
+		eorig = TEEC_ORIGIN_API;
+		goto out_free_temp_refs;
+	}
+
+	rc = ioctl(session->imp.ctx->imp.fd, TEE_IOC_INVOKE, &buf_data);
+	if (rc) {
+		EMSG("TEE_IOC_INVOKE failed");
+		eorig = TEEC_ORIGIN_COMMS;
+		res = ioctl_errno_to_res(errno);
+		goto out_free_temp_refs;
+	}
+
+	res = arg->ret;
+	eorig = arg->ret_origin;
+	teec_post_process_operation(operation, params, shm);
+
+	// MOD: temporary statistic code
+	mutex_mem = TEEC_Mutex_Pool_Size(&teec_mutex_pool);
+	if (mutex_mem > operation->params[3].value.a) {
+		operation->params[3].value.a = mutex_mem;
+	}
+
+out_free_temp_refs:
+	teec_free_temp_refs(operation, shm);
+out:
+	if (error_origin)
+		*error_origin = eorig;
+	return res;
+}
+
+void TEEC_RequestCancellation(TEEC_Operation *operation)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Session *session = NULL;
+	struct tee_ioctl_cancel_arg arg;
+
+	memset(&arg, 0, sizeof(arg));
+
+	if (!operation)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same operation
+	key = ADDR_TO_KEY(operation);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_mutex;
+	}
+
+	teec_mutex_lock(mutex);
+	session = operation->imp.session;
+	operation->imp.is_initialized = false;
+	teec_mutex_unlock(mutex);
+
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+
+	if (!session)
+		return;
+
+	arg.session = session->imp.session_id;
+	arg.cancel_id = 0;
+
+	if (ioctl(session->imp.ctx->imp.fd, TEE_IOC_CANCEL, &arg))
+		EMSG("TEE_IOC_CANCEL: %s", strerror(errno));
+}
+
+TEEC_Result TEEC_RegisterSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	TEEC_Result res = TEEC_SUCCESS;
+	int fd = 0;
+	size_t s = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->buffer)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.shadow_buffer = NULL;
+			shm->imp.flags = 0;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		/*
+		 * If we're here TEE_IOC_SHM_REGISTER failed, probably
+		 * because some read-only memory was supplied and the Linux
+		 * kernel doesn't like that at the moment.
+		 *
+		 * The error could also have some other origin. In any case
+		 * we're not making matters worse by trying to allocate and
+		 * register a shadow buffer before giving up.
+		 */
+		shm->imp.shadow_buffer = teec_paged_aligned_alloc(s);
+		if (!shm->imp.shadow_buffer) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		fd = teec_shm_register(ctx->imp.fd, shm->imp.shadow_buffer, s,
+				       &shm->imp.id);
+		if (fd >= 0) {
+			shm->imp.registered_fd = fd;
+			shm->imp.flags = SHM_FLAG_SHADOW_BUFFER_ALLOCED;
+			shm->imp.is_initialized = true;
+			goto out;
+		}
+
+		if (errno == ENOMEM)
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+		else
+			res = TEEC_ERROR_GENERIC;
+		free(shm->imp.shadow_buffer);
+		shm->imp.shadow_buffer = NULL;
+		// MOD: release mutex
+		teec_mutex_unlock(mutex);
+		TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+		return res;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+
+		shm->imp.shadow_buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+					  MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->imp.shadow_buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			// MOD: release mutex
+			teec_mutex_unlock(mutex);
+			TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+			return TEEC_ERROR_OUT_OF_MEMORY;
+		}
+		shm->imp.registered_fd = -1;
+		shm->imp.flags = 0;
+		shm->imp.is_initialized = true;
+	}
+
+out:
+	shm->imp.alloced_size = s;
+	// MOD: release mutex
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_RegisterSharedMemoryFileDescriptor(TEEC_Context *ctx,
+						    TEEC_SharedMemory *shm,
+						    int fd)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	int rfd = 0;
+	struct tee_ioctl_shm_register_fd_data data;
+
+	memset(&data, 0, sizeof(data));
+
+	if (!ctx || !shm || fd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	data.fd = fd;
+	rfd = ioctl(ctx->imp.fd, TEE_IOC_SHM_REGISTER_FD, &data);
+	if (rfd < 0)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	shm->buffer = NULL;
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.registered_fd = rfd;
+	shm->imp.id = data.id;
+	shm->size = data.size;
+	shm->imp.is_initialized = true;
+	goto out;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+	return TEEC_SUCCESS;
+}
+
+TEEC_Result TEEC_AllocateSharedMemory(TEEC_Context *ctx, TEEC_SharedMemory *shm)
+{
+	int fd = 0;
+	size_t s = 0;
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+	TEEC_Result res = TEEC_SUCCESS;
+
+	if (!ctx || !shm)
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	if (!shm->flags || (shm->flags & ~(TEEC_MEM_INPUT | TEEC_MEM_OUTPUT)))
+		return TEEC_ERROR_BAD_PARAMETERS;
+
+	s = shm->size;
+	if (!s)
+		s = 8;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid initializing a shm more than once
+	/* we comment the flag check for compatibility with existing apps,
+	   since it requires the shm object to be initialized with 0
+	*/
+	// if (shm->imp.is_initialized) {
+	// 	res = TEEC_ERROR_BAD_PARAMETERS;
+	// 	goto out;
+	// }
+
+	if (ctx->imp.reg_mem) {
+		shm->buffer = teec_paged_aligned_alloc(s);
+		if (!shm->buffer) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		fd = teec_shm_register(ctx->imp.fd, shm->buffer, s, &shm->imp.id);
+		if (fd < 0) {
+			free(shm->buffer);
+			shm->buffer = NULL;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = fd;
+	} else {
+		fd = teec_shm_alloc(ctx->imp.fd, s, &shm->imp.id);
+		if (fd < 0) {
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+
+		shm->buffer = mmap(NULL, s, PROT_READ | PROT_WRITE,
+				   MAP_SHARED, fd, 0);
+		close(fd);
+		if (shm->buffer == (void *)MAP_FAILED) {
+			shm->imp.id = -1;
+			res = TEEC_ERROR_OUT_OF_MEMORY;
+			goto out;
+		}
+		shm->imp.registered_fd = -1;
+	}
+
+	shm->imp.shadow_buffer = NULL;
+	shm->imp.alloced_size = s;
+	shm->imp.flags = SHM_FLAG_BUFFER_ALLOCED;
+	shm->imp.is_initialized = true;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+
+	return res;
+}
+
+void TEEC_ReleaseSharedMemory(TEEC_SharedMemory *shm)
+{
+	uint64_t key = 0;
+	pthread_mutex_t *mutex = NULL;
+
+	if (!shm)
+		return;
+
+	// MOD: add mutex for multi-thread CA call on the same shm
+	key = ADDR_TO_KEY(shm);
+	mutex = TEEC_Mutex_Pool_Get(&teec_mutex_pool, key);
+	if (!mutex) {
+		mutex = &teec_shm_mutex;
+	}
+	teec_mutex_lock(mutex);
+
+	// MOD: avoid release an uninitialized shm
+	if (shm->imp.id == -1 || !shm->imp.is_initialized) {
+		goto out;
+	}
+
+	if (shm->imp.shadow_buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags &
+			    SHM_FLAG_SHADOW_BUFFER_ALLOCED)
+				free(shm->imp.shadow_buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->imp.shadow_buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->buffer) {
+		if (shm->imp.registered_fd >= 0) {
+			if (shm->imp.flags & SHM_FLAG_BUFFER_ALLOCED)
+				free(shm->buffer);
+			close(shm->imp.registered_fd);
+		} else {
+			munmap(shm->buffer, shm->imp.alloced_size);
+		}
+	} else if (shm->imp.registered_fd >= 0) {
+		close(shm->imp.registered_fd);
+	}
+
+	shm->imp.id = -1;
+	shm->imp.shadow_buffer = NULL;
+	shm->buffer = NULL;
+	shm->imp.registered_fd = -1;
+	shm->imp.flags = 0;
+	shm->imp.is_initialized = false;
+
+	// MOD: release mutex
+out:
+	teec_mutex_unlock(mutex);
+	TEEC_Mutex_Pool_Unset(&teec_mutex_pool, key);
+}
diff --git a/libteec/src/teec_mutex_pool.c b/libteec/src/teec_mutex_pool.c
new file mode 100644
index 0000000..46b0a4e
--- /dev/null
+++ b/libteec/src/teec_mutex_pool.c
@@ -0,0 +1,85 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <teec_trace.h>
+
+#include <teec_mutex_pool.h>
+
+static pthread_mutex_t pool_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+/*-------------------------------------------------------------------------*/
+/**
+ * TEEC_Mutex_Pool_Get - Get a mutex from a pool.
+ *
+ * @param    pool    TEEC_Mutex_Pool object to search.
+ * @param    key     Key to look for in the pool.
+ * @return   a pointer to internally allocated mutex.
+ *
+ * This function locates a key in a pool and returns a pointer to its
+ * value (mutex), or null pointer if no such key can be found in pool
+ * and the pool is used up.
+ */
+/*--------------------------------------------------------------------------*/
+pthread_mutex_t *TEEC_Mutex_Pool_Get(TEEC_Mutex_Pool *pool, uint64_t key)
+{
+    size_t i;
+
+    if (key == POOL_INVALID_KEY)
+      return NULL;
+
+    pthread_mutex_lock(&pool_mutex);
+
+    for (i = 0; i < TEEC_MUTEX_POOL_MAX_SIZE; i++) {
+        if (key == pool->key[i]) {
+          pthread_mutex_unlock(&pool_mutex);
+          return &(pool->val[i]);
+        }
+    }
+
+    for (i = 0; i < TEEC_MUTEX_POOL_MAX_SIZE; i++) {
+        if (pool->key[i] == POOL_INVALID_KEY) {
+          pool->key[i] = key;
+          pthread_mutex_unlock(&pool_mutex);
+          return &(pool->val[i]);
+        }
+    }
+
+    pthread_mutex_unlock(&pool_mutex);
+    return NULL;
+}
+
+/*-------------------------------------------------------------------------*/
+/**
+ * TEEC_Mutex_Pool_Unset - Remove a key in a pool.
+ *
+ * @param    pool    TEEC_Mutex_Pool object to search.
+ * @param    key     Key to remove.
+ *
+ * This function removes a key in a pool. Nothing is done if the
+ * key cannot be found.
+ */
+/*--------------------------------------------------------------------------*/
+void TEEC_Mutex_Pool_Unset(TEEC_Mutex_Pool *pool, uint64_t key)
+{
+    size_t i;
+
+    if (key == POOL_INVALID_KEY)
+      return;
+
+    pthread_mutex_lock(&pool_mutex);
+
+    for (i = 0; i < TEEC_MUTEX_POOL_MAX_SIZE; i++) {
+        if (key == pool->key[i]) {
+          pool->key[i] = POOL_INVALID_KEY;
+          pthread_mutex_unlock(&pool_mutex);
+          return;
+        }
+    }
+
+    pthread_mutex_unlock(&pool_mutex);
+}
+
+size_t TEEC_Mutex_Pool_Size(TEEC_Mutex_Pool *pool) {
+  return sizeof(*pool);
+}
\ No newline at end of file
diff --git a/libteec/src/teec_mutex_pool_v2.c b/libteec/src/teec_mutex_pool_v2.c
new file mode 100644
index 0000000..1599dfa
--- /dev/null
+++ b/libteec/src/teec_mutex_pool_v2.c
@@ -0,0 +1,108 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <teec_trace.h>
+
+#include <teec_mutex_pool_v2.h>
+
+static pthread_mutex_t pool_mutex_v2 = PTHREAD_MUTEX_INITIALIZER;
+
+/*-------------------------------------------------------------------------*/
+/**
+ * TEEC_Mutex_Pool_V2_Get - Get a mutex from a pool.
+ *
+ * @param    pool    TEEC_Mutex_Pool object to search.
+ * @param    key     Key to look for in the pool.
+ * @return   a pointer to internally allocated mutex.
+ *
+ * This function locates a key in a pool and returns a pointer to its
+ * value (mutex), or null pointer if no such key can be found in pool
+ * and the pool is used up.
+ */
+/*--------------------------------------------------------------------------*/
+pthread_mutex_t *TEEC_Mutex_Pool_V2_Get(TEEC_Mutex_Pool_V2 *pool, uint64_t key)
+{
+    size_t i;
+
+    if (key == POOL_INVALID_KEY)
+      return NULL;
+
+    pthread_mutex_lock(&pool_mutex_v2);
+
+    if (pool->key == NULL || pool->val == NULL) {
+      pool->key = malloc(sizeof(uint64_t) * 1024);
+      pool->val = malloc(sizeof(pthread_mutex_t) * 1024);
+      pool->capacity = 1024;
+      pool->size = 0;
+    } else if (pool->size == pool->capacity) {
+      pool->capacity += TEEC_MUTEX_POOL_STEP_SIZE;
+      uint64_t *ptr_key = malloc(sizeof(uint64_t) * pool->capacity);
+      pthread_mutex_t *ptr_val = malloc(sizeof(pthread_mutex_t) * pool->capacity);
+      memcpy(ptr_key, pool->key, sizeof(uint64_t) * pool->size);
+      memcpy(ptr_val, pool->val, sizeof(pthread_mutex_t) * pool->size);
+      free(pool->key);
+      free(pool->val);
+      pool->key = ptr_key;
+      pool->val = ptr_val;
+    }
+
+    for (i = 0; i < pool->capacity; i++) {
+        if (key == pool->key[i]) {
+          pthread_mutex_unlock(&pool_mutex_v2);
+          return &(pool->val[i]);
+        }
+    }
+
+    for (i = 0; i < pool->capacity; i++) {
+        if (pool->key[i] == POOL_INVALID_KEY) {
+          pool->key[i] = key;
+          pool->size += 1;
+          pthread_mutex_unlock(&pool_mutex_v2);
+          return &(pool->val[i]);
+        }
+    }
+
+    pthread_mutex_unlock(&pool_mutex_v2);
+    return NULL;
+}
+
+/*-------------------------------------------------------------------------*/
+/**
+ * TEEC_Mutex_Pool_V2_Unset - Remove a key in a pool.
+ *
+ * @param    pool    TEEC_Mutex_Pool object to search.
+ * @param    key     Key to remove.
+ *
+ * This function removes a key in a pool. Nothing is done if the
+ * key cannot be found.
+ */
+/*--------------------------------------------------------------------------*/
+void TEEC_Mutex_Pool_V2_Unset(TEEC_Mutex_Pool_V2 *pool, uint64_t key)
+{
+    size_t i;
+
+    if (key == POOL_INVALID_KEY)
+      return;
+
+    pthread_mutex_lock(&pool_mutex_v2);
+
+    for (i = 0; i < TEEC_MUTEX_POOL_MAX_SIZE; i++) {
+        if (key == pool->key[i]) {
+          pool->key[i] = POOL_INVALID_KEY;
+          pool->size -= 1;
+          pthread_mutex_unlock(&pool_mutex_v2);
+          return;
+        }
+    }
+
+    pthread_mutex_unlock(&pool_mutex_v2);
+}
+
+size_t TEEC_Mutex_Pool_V2_Size(TEEC_Mutex_Pool_V2 *pool) {
+  size_t size;
+  pthread_mutex_lock(&pool_mutex_v2);
+  size = (sizeof(uint64_t) + sizeof(pthread_mutex_t)) * pool->size;
+  pthread_mutex_unlock(&pool_mutex_v2);
+  return size;
+}
